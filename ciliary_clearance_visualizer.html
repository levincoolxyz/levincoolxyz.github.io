<!doctype html>
<html lang="en">
<head>
<!-- CC BY-NC-SA 4.0 (Attribution-NonCommercial-ShareAlike) https://creativecommons.org/licenses/by-nc-sa/4.0/ -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ciliary Clearance Visualizer</title>
<style>
  :root{--bg:#0b0d12;--fg:#e8eaed;--muted:#9aa0a6;--acc:#8ab4f8;--panel:#0f131d;--border:#1f2937}
  html,body{height:100%;margin:0}
  body{background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif}
  .app{display:grid;grid-template-columns:minmax(260px,360px) 1fr;grid-template-rows:auto 1fr;height:100%}
  .app>*{min-width:0;min-height:0}
  header{grid-column:1 / -1;padding:8px 12px;border-bottom:1px solid var(--border);background:#0f1113}
  header .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  header h1{font-size:16px;margin:0 12px 0 0;color:var(--fg)}
  header small{color:var(--muted)}
  .panel{background:var(--panel);border-right:1px solid var(--border);padding:12px;overflow:auto}
  .btn-toggle{background:#10192a;color:var(--fg);border:1px solid #2c3a4d;padding:6px;border-radius:8px;cursor:pointer;width:36px;height:36px;display:inline-flex;align-items:center;justify-content:center}
  .btn-toggle:hover{background:#162236}
  .app.collapsed{grid-template-columns:0 1fr}
  .app.collapsed .panel{padding:0;overflow:hidden;pointer-events:none;opacity:0;transform:translateX(-12px);border-right-color:transparent}
  main.canvas-wrap{position:relative;display:flex;align-items:center;justify-content:center;background:#0f1113}
  #view{position:relative;flex:1;width:100%;height:100%;min-height:clamp(280px,60vh,740px);display:flex;align-items:center;justify-content:center}
  #view canvas{display:block;max-width:100%;max-height:100%}
  .panel h2{margin:0 0 8px 0;font-size:15px}
  .group{margin:8px 0 14px}
  .row{display:grid;grid-template-columns:1fr minmax(120px,160px);gap:8px;align-items:center;margin:6px 0}
  .row label{font-size:12px;color:var(--muted)}
  .row input[type=range]{width:100%}
  .row input[type=number], .row select{width:100%;background:#111827;color:var(--fg);border:1px solid #2f3847;border-radius:8px;padding:6px}
  .hint{font-size:12px;color:var(--muted);margin-top:4px}
  .btn{background:#10192a;color:#fff;border:0;border-radius:10px;padding:8px 10px;cursor:pointer}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  #stats{position:absolute;left:8px;bottom:8px;font:12px ui-monospace;color:#cbd5e1;background:rgba(0,0,0,.45);padding:6px 8px;border-radius:8px;white-space:pre}
  #scalebar{position:absolute;right:16px;bottom:16px;display:flex;flex-direction:column;align-items:flex-end;gap:4px;z-index:2}
  #bar{height:3px;background:#e5e7eb;border-radius:3px;box-shadow:0 0 0 1px rgba(0,0,0,.35) inset}
  #barlabel{font:12px ui-monospace;color:#e5e7eb;text-shadow:0 1px 0 rgba(0,0,0,.6)}
  #err{position:fixed;right:12px;bottom:12px;max-width:44ch;background:#2b1b1b;color:#ffdcdc;border:1px solid #a55;padding:8px 10px;border-radius:10px;font:12px ui-monospace;display:none;white-space:pre-wrap;z-index:100}
  a{color:var(--acc)}
  @media (max-width:900px){
    .app{grid-template-columns:1fr;grid-template-rows:auto auto 1fr}
    .panel{grid-column:1 / -1}
    .app.collapsed{grid-template-columns:1fr}
    main.canvas-wrap{grid-column:1 / -1;min-height:50vh}
    #view{min-height:clamp(260px,60vh,600px)}
  }
  @media (max-width:600px), (orientation:portrait){
    header h1{font-size:15px}
    .btn-toggle{width:34px;height:34px}
    #view{min-height:clamp(220px,55vh,520px)}
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="row">
      <button id="togglePanel" class="btn-toggle" title="Collapse/expand panel">&lt;&lt;</button>
      <h1>Ciliary Clearance Visualizer</h1>
      <button id="playPause" class="btn">Pause</button>
      <button id="reset" class="btn">Reset tracers</button>
      <small>Regularized stokeslets with wall</small>
    </div>
  </header>

  <aside class="panel">
    <h2>Controls</h2>
    <div class="group">
      <div class="row"><label>Preset</label>
        <div>
          <select id="preset" title="Examples vary three axes: coverage (sparse/dense), alignment (aligned/misaligned), patches (regular/disordered)">
            <option value="custom">Custom</option>
            <option value="example1" title="sparse, aligned, regular">Example 1 — sparse, aligned, regular</option>
            <option value="example2" title="dense, aligned, regular">Example 2 — dense, aligned, regular</option>
            <option value="example3" title="sparse, misaligned, regular">Example 3 — sparse, misaligned, regular</option>
            <option value="example4" title="dense, misaligned, regular">Example 4 — dense, misaligned, regular</option>
            <option value="example5" title="sparse, aligned, disordered">Example 5 — sparse, aligned, disordered</option>
            <option value="example6" title="dense, aligned, disordered">Example 6 — dense, aligned, disordered</option>
            <option value="example7" title="sparse, misaligned, disordered">Example 7 — sparse, misaligned, disordered</option>
            <option value="example8" title="dense, misaligned, disordered">Example 8 — dense, misaligned, disordered</option>
            <option value="human_avg">human_avg</option>
            <option value="human_max">human_max</option>
            <option value="human_min">human_min</option>
            <option value="rat_avg">rat_avg</option>
            <option value="rat_max">rat_max</option>
            <option value="rat_min">rat_min</option>
            <option value="bd_avg">bd_avg</option>
            <option value="bd_max">bd_max</option>
            <option value="bd_min">bd_min</option>
            <option value="mair_avg">mair_avg</option>
            <option value="mair_max">mair_max</option>
            <option value="mair_min">mair_min</option>
            <option value="pc_avg">pc_avg</option>
            <option value="pc_max">pc_max</option>
            <option value="pc_min">pc_min</option>
            <option value="pcs_avg">pcs_avg</option>
            <option value="pcs_max">pcs_max</option>
            <option value="pcs_min">pcs_min</option>
            <option value="sagm_avg">sagm_avg</option>
            <option value="sagm_max">sagm_max</option>
            <option value="sagm_min">sagm_min</option>
            <option value="pc_atp">pc_atp</option>
            <option value="pc_atp_max">pc_atp_max</option>
            <option value="pc_atp_min">pc_atp_min</option>
            <option value="pcs_atp">pcs_atp</option>
            <option value="pcs_atp_max">pcs_atp_max</option>
            <option value="pcs_atp_min">pcs_atp_min</option>
            <option value="pc_muc">pc_muc</option>
            <option value="pc_muc_max">pc_muc_max</option>
            <option value="pc_muc_min">pc_muc_min</option>
            <option value="pcs_muc">pcs_muc</option>
            <option value="pcs_muc_max">pcs_muc_max</option>
            <option value="pcs_muc_min">pcs_muc_min</option>
            <option value="pc_D37">pc_D37</option>
          </select>
        </div>
      </div>
      <div class="hint" style="grid-column:1 / -1">Examples vary: coverage (sparse↔dense), alignment (aligned↔misaligned), patches (regular↔disordered).</div>
    </div>
    <div class="group">
      <div class="row"><label>Modifier</label>
        <div>
          <select id="mod">
            <option value="none">(none)</option>
            <option value="human_h">human_h</option>
            <option value="human_ap">human_ap</option>
            <option value="human_oop">human_oop</option>
            <option value="human_diff">human_diff</option>
            <option value="human_not_h">human_not_h</option>
            <option value="human_not_ap">human_not_ap</option>
            <option value="human_not_oop">human_not_oop</option>
            <option value="human_not_diff">human_not_diff</option>
          </select>
        </div>
      </div>
    </div>
    <div class="group">
      <div class="row"><label>Grid size X</label><input id="nX" type="range" min="6" max="40" step="1" value="21"></div>
      <div class="row"><label>Grid size Y</label><input id="nY" type="range" min="6" max="40" step="1" value="21"></div>
      <div class="row"><label>Grid spacing</label><input id="spacing" type="range" min="0.5" max="2.0" step="0.01" value="1.0"></div>
    </div>
    <div class="group">
      <div class="row"><label>Coverage</label><input id="coverage" type="range" min="0" max="1" step="0.01" value="0.5"></div>
      <div class="row"><label>Patch length (λ/size)</label><input id="patchlength" type="range" min="0.05" max="1.0" step="0.01" value="0.6"></div>
      <div class="row"><label>Crystalline jitter</label><input id="crystalline" type="range" min="0" max="2" step="0.01" value="1.06"></div>
      <div class="row"><label>Patch order</label><input id="patchorder" type="range" min="0" max="1" step="0.01" value="0.5"></div>
    </div>
    <div class="group">
      <div class="row"><label>Angle std (deg)</label><input id="angleStd" type="range" min="0" max="90" step="1" value="11"></div>
      <div class="row"><label>Cilia height h [au]</label><input id="ciliaH" type="range" min="0.2" max="2.0" step="0.01" value="1.0"></div>
      <div class="row"><label>Beat amplitude a [au]</label><input id="amp" type="range" min="0.1" max="2.0" step="0.01" value="1.0"></div>
      <div class="row"><label>Regularisation ε</label><input id="eps" type="range" min="0.02" max="0.8" step="0.01" value="0.10"></div>
      <div class="row"><label>Diffusion D</label><input id="diff" type="range" min="0" max="0.2" step="0.001" value="0.01"></div>
      <div class="row"><label>dt</label><input id="dt" type="range" min="0.01" max="0.2" step="0.005" value="0.05"></div>
    </div>
    <div class="group">
      <div class="row"><label>Tracer count</label><input id="nTracer" type="range" min="10" max="500" step="1" value="60"></div>
      <div class="row"><label>Trail length (frames)</label><input id="trail" type="range" min="5" max="300" step="1" value="120"></div>
    </div>
    <div class="group">
      <div class="row"><label>Scale bar [μm]</label><input id="barum" type="range" min="1" max="50" step="1" value="10"></div>
      <div class="row"><label>Animated ciliated cells</label>
        <div><input id="showCilia" type="checkbox"></div>
      </div>
    </div>
  </aside>

  <main class="canvas-wrap">
    <div id="view"><canvas id="canvas"></canvas></div>
    <div id="stats">—</div>
    <div id="scalebar"><div id="bar"></div><div id="barlabel"></div></div>
    <div id="err"></div>
  </main>
</div>

<script type="module">
// Optional ESM import helper (for voronoi)
async function importWithFallback(candidates){
  for (const url of candidates){
    try { return await import(url); } catch (e) { console.warn('Import failed', url, e); }
  }
  throw new Error('All import candidates failed');
}
// ===== Shared helpers reused from existing visualizers =====
// Define base length scales up front so scale bar etc. can use them immediately
const L0 = 10;      // [um] typical cell size
const L0m = 10E-6;  // [m]  typical cell size
function randn(){ let u=0,v=0; while(!u) u=Math.random(); while(!v) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
function clamp(v,a,b){ return Math.min(b, Math.max(a, v)); }
function wrapCenter(r, r0, size){ // wrap r centered around r0 +/- size/2
  return ((r - r0 - size/2) % size + size) % size + r0 - size/2;
}
// presence and patching (ported from cilia_bundle_tracer_visualizer)
function shape1d(x,a){ const m = ((x+1)%2+2)%2; return (m <= 2*a) ? (m/a - 1) : (1 - (m-2*a)/(1-a)); }
function presence(cx, cy, coverage, patchlength, crystalline, patchorder, nCols, nRows, dX, dY){
  const n = cx.length; const out = new Array(n);
  function seedAt(x,y){ const px = Math.floor((x + (nCols-1)*dX/2) / dX); const py = Math.floor((y + (nRows-1)*dY/2) / dY); const s = Math.sin(px*12.9898 + py*78.233)*43758.5453; return s - Math.floor(s); }
  for (let i=0;i<n;i++){
    const seed = seedAt(cx[i]+(Math.random()-0.5)*crystalline, cy[i]+(Math.random()-0.5)*crystalline);
    let a = (seed-0.5)*patchorder + 0.5; a = clamp(a, 0.01, 0.99);
    const pot = Math.min(
      shape1d(cx[i]/Math.max(1,(nCols-1)*dX)/patchlength, a),
      shape1d(cy[i]/Math.max(1,(nRows-1)*dY)/patchlength, a)
    );
    out[i] = (pot >= (1 - 2*coverage));
  }
  return out;
}

// Inlined stokesletWithWall.js (from javascripts/stokesletWithWall.js)
function stokesletWithWall(Xq, X, F, eps){
  const N = Math.floor((X && X.length) ? X.length / 3 : 0);
  const nQ = Math.floor((Xq && Xq.length) ? Xq.length / 3 : 0);
  const out = new Float64Array(3 * nQ);
  if (N === 0 || nQ === 0) { return out; }
  const Fx = F.subarray(0, N);
  const Fy = F.subarray(N, 2 * N);
  const Fz = F.subarray(2 * N, 3 * N);
  const X1 = X.subarray(0, N);
  const X2 = X.subarray(N, 2 * N);
  const X3 = X.subarray(2 * N, 3 * N);
  const PI = Math.PI;
  function epsAt(i){
    if (typeof eps === 'number') return eps;
    if (!eps) return 1e-6;
    if (Array.isArray(eps) || eps instanceof Float32Array || eps instanceof Float64Array){ if (eps.length === 1) return eps[0]; return eps[i] != null ? eps[i] : eps[0]; }
    return Number(eps) || 1e-6;
  }
  for (let qi = 0; qi < nQ; qi++){
    const qx = Xq[qi], qy = Xq[qi + nQ], qz = Xq[qi + 2 * nQ];
    let u = 0, v = 0, w = 0;
    for (let i = 0; i < N; i++){
      const ex = X1[i], ey = X2[i], ez = X3[i];
      const Fx_i = Fx[i], Fy_i = Fy[i], Fz_i = Fz[i];
      const eVal = epsAt(i), e2 = eVal * eVal;
      const xs1 = qx - ex, xs2 = qy - ey, xs3 = qz - ez;
      const xi1 = qx + ex, xi2 = qy - ey, xi3 = qz - ez;
      const rs2 = xs1*xs1 + xs2*xs2 + xs3*xs3;
      const r2  = xi1*xi1 + xi2*xi2 + xi3*xi3;
      const rser = Math.sqrt(rs2 + e2), rser3 = rser*rser*rser;
      const rer  = Math.sqrt(r2  + e2), rer3  = rer*rer*rer, rer5 = rer3*rer*rer;
      const H1s = (1/rser + e2/rser3) / (8*PI);
      const H2s = 1 / (rser3 * 8 * PI);
      const H1 = (1/rer + e2/rer3) / (8*PI);
      const H2 = 1 / (rer3 * 8 * PI);
      const H1pr = (-1/rer3 - 3*e2/rer5) / (8*PI);
      const H2pr = -3 / (rer5 * 8 * PI);
      const D1 = (1/rer3 - 3*e2/rer5) / (4*PI);
      const D2 = -3 / (rer5 * 4 * PI);
      const Gx = Fx_i, Gy = -Fy_i, Gz = -Fz_i;
      const GrotP = Gx*xi1 + Gy*xi2 + Gz*xi3;
      const Fxs = Fx_i*xs1 + Fy_i*xs2 + Fz_i*xs3;
      const FrotP = Fx_i*xi1 + Fy_i*xi2 + Fz_i*xi3;
      const LCx1 = Fz_i*xi3 + Fy_i*xi2;
      const LCx2 = -Fy_i*xi1;
      const LCx3 = -Fz_i*xi1;
      const xsCoeff = Fxs*H2s;
      const Lcoeff = 2*ex*(H1pr + H2);
      const Xcoeff = 2*ex*(Gx*H2 + xi1*GrotP*H2pr) - FrotP*H2 - ex*ex*GrotP*D2;
      const Fcoeff = H1s - H1;
      const Gcoeff = 2*ex*xi1*H2 - ex*ex*D1;
      u += Fcoeff*Fx_i + xsCoeff*xs1 + Xcoeff*xi1 + Lcoeff*LCx1 + Gcoeff*Gx + 2*ex*GrotP*H1pr;
      v += (H1s-H1)*Fy_i + xsCoeff*xs2 + Xcoeff*xi2 + Lcoeff*LCx2 + Gcoeff*Gy;
      w += (H1s-H1)*Fz_i + xsCoeff*xs3 + Xcoeff*xi3 + Lcoeff*LCx3 + Gcoeff*Gz;
    }
    out[qi] = u; out[qi + nQ] = v; out[qi + 2 * nQ] = w;
  }
  return out;
}

// ===== App state =====
const params = {
  nX:21, nY:21, spacing:1.0,
  coverage:0.5, patchlength:0.6, crystalline:1.06, patchorder:0.5,
  angleStdDeg:11, ciliaH:1.0, amp:1.0, eps:0.10, diff:0.01, dt:0.05,
  nTracer:60, trail:120,
  barum:10, // scale bar (um)
  showCilia:false, // animated cilia sticks
};

const sim = {
  playing:true,
  cx:null, cy:null, cz:null, isCiliated:null,
  xSize:0, ySize:0, dX:1, dY:1, total:0, totalCiliated:0,
  ang:null,
  XsrcFull:null, FsrcFull:null,
  tracers:[], trails:[],
  canvas:null, ctx:null, W:800, H:600, scale:20,
  vor:null,
  time:0,
  ciliaSeeds:null,
  overlayCanvas:null,
  overlayCtx:null,
};

// ===== UI wiring =====
function byId(id){ return document.getElementById(id); }
function setSlider(id, v){ const el=byId(id); if (el) el.value=String(v); }
function connect(){
  byId('togglePanel')?.addEventListener('click', ()=>{ document.querySelector('.app')?.classList.toggle('collapsed'); });
  byId('playPause')?.addEventListener('click', ()=>{ sim.playing=!sim.playing; byId('playPause').textContent = sim.playing? 'Pause':'Play'; });
  byId('reset')?.addEventListener('click', ()=>{ seedTracers(); });
  byId('preset')?.addEventListener('change', ()=>{ const name = byId('preset').value; if (name !== 'custom'){ applyPreset(name); syncUIFromParams(); rebuild(); } });
  byId('mod')?.addEventListener('change', ()=>{ const name = byId('mod').value; if (name && name!=='none'){ applyMod(name); syncUIFromParams(); rebuild(); } });
  const map = [
    ['nX','nX'],['nY','nY'],['spacing','spacing'],
    ['coverage','coverage'],['patchlength','patchlength'],['crystalline','crystalline'],['patchorder','patchorder'],
    ['angleStd','angleStdDeg'],['ciliaH','ciliaH'],['amp','amp'],['eps','eps'],['diff','diff'],['dt','dt'],
    ['nTracer','nTracer'],['trail','trail'], ['barum','barum']
  ];
  for (const [id,key] of map){ const el=byId(id); if (!el) continue; el.addEventListener('input', ()=>{ const v=Number(el.value); params[key] = v; if(['nX','nY','spacing','coverage','patchlength','crystalline','patchorder','ciliaH','amp','angleStdDeg','eps'].includes(key)){ rebuild(); } }); }
  const sc = byId('showCilia'); if (sc){ sc.checked = params.showCilia; sc.addEventListener('change', ()=>{ params.showCilia = !!sc.checked; }); }
}

// ===== Grid and sources =====
function generateGrid(){
  const nX = Math.max(2, Math.floor(params.nX));
  const nY = Math.max(2, Math.floor(params.nY));
  const dX = Math.max(0.2, Number(params.spacing));
  const dY = dX;
  sim.dX = dX; sim.dY = dY;
  const xSize = (nX-1)*dX, ySize = (nY-1)*dY; sim.xSize=xSize; sim.ySize=ySize;
  const coordx = new Array(nX), coordy=new Array(nY);
  for(let i=0;i<nX;i++){ coordx[i] = -xSize/2 + (nX>1 ? i*(xSize/(nX-1)) : 0); }
  for(let j=0;j<nY;j++){ coordy[j] = -ySize/2 + (nY>1 ? j*(ySize/(nY-1)) : 0); }
  const cx=[], cy=[], cz=[];
  for(let j=0;j<nY;j++){
    for(let i=0;i<nX;i++){
      const jitter = params.crystalline;
      cx.push(coordx[i] + (Math.random()-0.5)*jitter);
      cy.push(coordy[j] + (Math.random()-0.5)*jitter);
      cz.push(params.ciliaH);
    }
  }
  sim.cx = Float64Array.from(cx); sim.cy=Float64Array.from(cy); sim.cz=Float64Array.from(cz); sim.total = nX*nY;
  sim.isCiliated = presence(sim.cx, sim.cy, params.coverage, params.patchlength, params.crystalline, params.patchorder, nX, nY, dX, dY).map(b=>!!b);
  sim.totalCiliated = sim.isCiliated.reduce((a,b)=>a+(b?1:0),0);
}

function reseedAngles(){
  const n = sim.total; sim.ang = new Float64Array(n);
  const s = (params.angleStdDeg||0) * Math.PI/180;
  for(let i=0;i<n;i++){ sim.ang[i] = s>0? s*randn() : 0; }
}

function buildSources(){
  // Build source arrays X: [z; x; y] and F: [Fz; Fx; Fy] for ciliated cells only
  const N = sim.totalCiliated;
  const X = new Float64Array(N*3);
  const F = new Float64Array(N*3);
  let k=0;
  for(let i=0;i<sim.total;i++){
    if (!sim.isCiliated[i]) continue;
    const z = sim.cz[i];
    const ang = sim.ang[i] || 0; // around x-y plane
    const fx = Math.cos(ang) * params.amp;
    const fy = Math.sin(ang) * params.amp;
    X[k] = z; // wall at 0, height z
    X[k+N] = sim.cx[i];
    X[k+2*N] = sim.cy[i];
    F[k] = 0; // Fz
    F[k+N] = fx; // Fx
    F[k+2*N] = fy; // Fy
    k++;
  }
  sim.XsrcFull = X; sim.FsrcFull = F;
}

// ===== Voronoi patches (optional; offline fallback) =====
let DelaunayCtor = null;
try {
  const mod = await importWithFallback([
    'https://unpkg.com/d3-delaunay@6.0.2/dist/d3-delaunay.min.js?module',
    'https://cdn.skypack.dev/d3-delaunay@6'
  ]);
  DelaunayCtor = mod?.Delaunay ?? mod?.default?.Delaunay ?? mod?.default ?? null;
} catch (err) {
  console.warn('Voronoi: d3-delaunay import failed; using offline half-plane clipping');
}

function clipPolyHalfPlane(poly, a, b, c){
  if (!poly || poly.length===0) return [];
  const out = [];
  const n = poly.length;
  const EPS = 1e-9;
  function inside(x,y){ return a*x + b*y <= c + EPS; }
  function intersect(x1,y1,x2,y2){
    const dx = x2-x1, dy=y2-y1; const denom = a*dx + b*dy;
    if (Math.abs(denom) < 1e-12) return [x2,y2];
    const t = (c - a*x1 - b*y1) / denom; return [x1 + t*dx, y1 + t*dy];
  }
  for (let i=0;i<n;i++){
    const j = (i+1)%n;
    const x1=poly[i][0], y1=poly[i][1];
    const x2=poly[j][0], y2=poly[j][1];
    const in1 = inside(x1,y1), in2 = inside(x2,y2);
    if (in1 && in2){ out.push([x2,y2]); }
    else if (in1 && !in2){ const p = intersect(x1,y1,x2,y2); out.push(p); }
    else if (!in1 && in2){ const p = intersect(x1,y1,x2,y2); out.push(p,[x2,y2]); }
  }
  return out;
}

function updateVoronoi(){
  const polys = new Array(sim.total);
  const rect = [
    [-sim.xSize/2, -sim.ySize/2],
    [ sim.xSize/2, -sim.ySize/2],
    [ sim.xSize/2,  sim.ySize/2],
    [-sim.xSize/2,  sim.ySize/2]
  ];
  if (DelaunayCtor){
    const pts = []; for (let i=0;i<sim.total;i++){ pts.push([sim.cx[i], sim.cy[i]]); }
    const delaunay = DelaunayCtor.from(pts, d=>d[0], d=>d[1]);
    const bounds = [-sim.xSize/2, -sim.ySize/2, sim.xSize/2, sim.ySize/2];
    const vor = delaunay.voronoi(bounds);
    for (let i=0;i<sim.total;i++){
      const poly = vor.cellPolygon(i);
      polys[i] = poly ? Array.from(poly) : rect.slice();
    }
  } else {
    // Offline: compute Voronoi cells via half-plane intersection
    for (let i=0;i<sim.total;i++){
      let poly = rect.slice();
      const xi = sim.cx[i], yi = sim.cy[i];
      for (let j=0;j<sim.total;j++){
        if (j===i) continue; const xj = sim.cx[j], yj = sim.cy[j];
        const a = xj - xi; const b = yj - yi; const c = 0.5*(xj*xj + yj*yj - xi*xi - yi*yi);
        poly = clipPolyHalfPlane(poly, a, b, c);
        if (poly.length===0) break;
      }
      polys[i] = poly;
    }
  }
  sim.vor = { polys };
  // Build cilia seeds uniformly per Voronoi polygon (only ciliated cells get seeds)
  initCiliaSeeds(polys);
}

function pointInPoly(poly, x, y){
  // ray casting
  let inside=false; for (let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi=poly[i][0], yi=poly[i][1]; const xj=poly[j][0], yj=poly[j][1];
    const intersect = ((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi+1e-12)+xi);
    if (intersect) inside=!inside;
  } return inside;
}

function initCiliaSeeds(polys){
  const seedsPerCellMin = 100, seedsPerCellMax = 150;
  const out = new Array(sim.total);
  for (let i=0;i<sim.total;i++){
    if (!sim.isCiliated[i]){ out[i]=null; continue; }
    const poly = polys[i]; if (!poly || poly.length<3){ out[i]=null; continue; }
    const pCell = Math.random();
    let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity;
    for (const p of poly){ if (p[0]<minx) minx=p[0]; if (p[0]>maxx) maxx=p[0]; if (p[1]<miny) miny=p[1]; if (p[1]>maxy) maxy=p[1]; }
    const want = seedsPerCellMin + Math.floor(Math.random()*(seedsPerCellMax-seedsPerCellMin+1));
    const seeds=[]; let tries=0;
    while (seeds.length < want && tries < want*50){
      tries++;
      const rx = minx + Math.random()*(maxx-minx);
      const ry = miny + Math.random()*(maxy-miny);
      if (pointInPoly(poly, rx, ry)) seeds.push({x:rx,y:ry,p:pCell});
    }
    out[i]=seeds;
  }
  sim.ciliaSeeds = out;
}

// ===== Tracers =====
function seedTracers(){
  const n = Math.max(1, Math.floor(params.nTracer));
  sim.tracers = new Array(n);
  sim.trails = new Array(n);
  for (let i=0;i<n;i++){
    sim.tracers[i] = { x:(Math.random()*sim.xSize - sim.xSize/2), y:(Math.random()*sim.ySize - sim.ySize/2), z: params.ciliaH, vx:0, vy:0, vz:0 };
    sim.trails[i] = [];
  }
}

// ===== Simulation step =====
const Xq = new Float64Array(3);
let Xwrap=null; // per-particle wrapped sources buffer
function step(dt){
  if (!sim.tracers || sim.tracers.length===0) return;
  const N = sim.totalCiliated; if (N<=0) return;
  const eps = Math.max(1e-6, Number(params.eps));
  if (!Xwrap || Xwrap.length !== sim.XsrcFull.length) Xwrap = new Float64Array(sim.XsrcFull.length);
  const periodX = sim.xSize + sim.dX;
  const periodY = sim.ySize + sim.dY;
  for (let p=0;p<sim.tracers.length;p++){
    const t = sim.tracers[p];
    // Build wrapped source positions for this tracer (minimum image convention per axis)
    for (let i=0, k=0;i<sim.total;i++){
      if (!sim.isCiliated[i]) continue;
      const z = sim.cz[i];
      const wx = wrapCenter(sim.cx[i], t.x, periodX);
      const wy = wrapCenter(sim.cy[i], t.y, periodY);
      Xwrap[k] = z; Xwrap[k+N] = wx; Xwrap[k+2*N] = wy; k++;
    }
    Xq[0] = Math.max(1e-6, t.z); Xq[1] = t.x; Xq[2] = t.y;
    const vel = stokesletWithWall(Xq, Xwrap, sim.FsrcFull, eps);
    // reorder components to (x,y,z)
    const vx = vel[1], vy = vel[2], vz = vel[0];
    // Euler–Maruyama update with diffusion
    const D = Math.max(0, Number(params.diff));
    t.vx = vx; t.vy = vy; t.vz = vz;
    t.x += vx*dt + Math.sqrt(2*D*dt) * randn();
    t.y += vy*dt + Math.sqrt(2*D*dt) * randn();
    t.z = params.ciliaH; // keep 2D plane at cilia height
    // periodic wrap
    t.x = wrapCenter(t.x, 0, sim.xSize + sim.dX);
    t.y = wrapCenter(t.y, 0, sim.ySize + sim.dY);
    // update trail
    const tr = sim.trails[p];
    tr.push({x:t.x, y:t.y}); if (tr.length > params.trail) tr.shift();
  }
}

// ===== Rendering =====
function resizeCanvas(){
  const c = sim.canvas; const view = byId('view');
  const w = view.clientWidth || 800; const h = view.clientHeight || 600;
  c.width = w; c.height = h; sim.W=w; sim.H=h;
  if (!sim.overlayCanvas){ sim.overlayCanvas = document.createElement('canvas'); }
  sim.overlayCanvas.width = w; sim.overlayCanvas.height = h;
  sim.overlayCtx = sim.overlayCanvas.getContext('2d', { alpha:true });
}
function draw(){
  const ctx = sim.ctx; const W=sim.W, H=sim.H; ctx.clearRect(0,0,W,H);
  // world -> screen transform (fit domain)
  const pad = 40; const sx = (W - 2*pad) / Math.max(1e-6, sim.xSize); const sy = (H - 2*pad) / Math.max(1e-6, sim.ySize); const s = Math.min(sx, sy); sim.scale = s;
  const cx0 = W/2, cy0 = H/2;
  function toXY(x,y){ return [cx0 + x*s, cy0 + y*s]; }
  // background (dark gray)
  ctx.fillStyle = '#1c1f24'; ctx.fillRect(0,0,W,H);
  // faint fundamental domain box only
  const [bx0, by0] = toXY(-sim.xSize/2, -sim.ySize/2);
  ctx.strokeStyle = 'rgba(230,230,230,.15)'; ctx.lineWidth = 2; ctx.strokeRect(bx0, by0, sim.xSize*s, sim.ySize*s);
  // Offscreen overlay: cells + arrows + cilia
  const octx = sim.overlayCtx; octx.clearRect(0,0,W,H);
  if (sim.vor && sim.vor.polys){
    for (let i=0;i<sim.total;i++){
      const poly = sim.vor.polys[i]; if (!poly) continue;
      octx.beginPath();
      for (let j=0;j<poly.length;j++){
        const [px, py] = toXY(poly[j][0], poly[j][1]);
        if (j===0) octx.moveTo(px, py); else octx.lineTo(px, py);
      }
      octx.closePath();
      octx.fillStyle = sim.isCiliated[i] ? 'rgba(210,210,210,0.18)' : 'rgba(140,140,140,0.12)';
      octx.fill();
      octx.strokeStyle = 'rgba(0,0,0,.65)'; octx.lineWidth = 1; octx.stroke();
    }
  }
  // arrows and optional cilia on overlay
  octx.lineWidth = 1.5; octx.strokeStyle = '#ff5050'; octx.fillStyle = '#ff5050';
  for (let i=0;i<sim.total;i++){
    if (!sim.isCiliated[i]) continue;
    const ang = sim.ang[i] || 0; const x = sim.cx[i], y = sim.cy[i]; const [sx0, sy0] = toXY(x,y);
    const L = 1.0 * s; const ux = Math.cos(ang), uy = Math.sin(ang);
    const tail=-0.4*L, vlen=0.7*L; const x0=sx0+tail*ux, y0=sy0+tail*uy; const x1=x0+vlen*ux, y1=y0+vlen*uy;
    const headLen=0.12*L, headWidth=0.10*L; const sx1=x1-headLen*ux, sy1=y1-headLen*uy; const pxp=-uy, pyp=ux;
    octx.beginPath(); octx.moveTo(x0,y0); octx.lineTo(sx1,sy1); octx.stroke();
    octx.beginPath(); octx.moveTo(x1,y1); octx.lineTo(sx1+(headWidth/2)*pxp, sy1+(headWidth/2)*pyp); octx.lineTo(sx1-(headWidth/2)*pxp, sy1-(headWidth/2)*pyp); octx.closePath(); octx.fill();
    if (params.showCilia && sim.ciliaSeeds && sim.ciliaSeeds[i]){
      const amp = Math.max(0, params.amp) * s; octx.lineWidth = 2;
      const seeds = sim.ciliaSeeds[i];
      for (let k=0;k<seeds.length;k++){
        const seed = seeds[k]; const tcyc = (sim.time + seed.p) % 1; let dir=1, len=0;
        if (tcyc < 0.2){ const u=tcyc/0.2; len=0.9*amp*Math.sin(0.5*Math.PI*u); dir=1; }
        else if (tcyc < 0.6){ const u=(tcyc-0.2)/0.4; len=0.9*amp*(1-Math.sin(0.5*Math.PI*u)); dir=1; }
        else if (tcyc < 0.7){ const u=(tcyc-0.6)/0.1; len=0.1*amp*Math.sin(0.5*Math.PI*u); dir=-1; }
        else if (tcyc < 0.9){ const u=(tcyc-0.7)/0.2; len=0.1*amp*(1-Math.sin(0.5*Math.PI*u)); dir=-1; }
        const dxs=Math.cos(ang)*len*dir, dys=Math.sin(ang)*len*dir; const [sx,sy]=toXY(seed.x,seed.y);
        octx.beginPath(); octx.moveTo(sx-0.2*dxs, sy-0.2*dys); octx.lineTo(sx+0.8*dxs, sy+0.8*dys); octx.stroke();
      }
      octx.lineWidth = 1.5;
    }
  }
  if (params.showCilia){ ctx.filter='blur(0.6px)'; ctx.drawImage(sim.overlayCanvas,0,0); ctx.filter='none'; }
  else { ctx.drawImage(sim.overlayCanvas,0,0); }
  // draw tracer trails and particles (respect periodic boundaries by breaking long chords)
  ctx.filter = 'none';
  for (let p=0;p<sim.tracers.length;p++){
    const tr = sim.trails[p];
    if (tr.length>1){
      ctx.strokeStyle='rgba(120,200,255,.8)';
      ctx.beginPath();
      let [sxPrev, syPrev] = toXY(tr[0].x, tr[0].y);
      ctx.moveTo(sxPrev, syPrev);
      for (let i=1;i<tr.length;i++){
        const dx = tr[i].x - tr[i-1].x;
        const dy = tr[i].y - tr[i-1].y;
        const wrapX = sim.xSize + sim.dX;
        const wrapY = sim.ySize + sim.dY;
        // break the polyline if the step crosses periodic boundary
        if (Math.abs(dx) > wrapX*0.5 || Math.abs(dy) > wrapY*0.5){
          const [sx, sy] = toXY(tr[i].x, tr[i].y);
          ctx.moveTo(sx, sy);
        } else {
          const [sx, sy] = toXY(tr[i].x, tr[i].y);
          ctx.lineTo(sx, sy);
        }
      }
      ctx.stroke();
    }
    const t = sim.tracers[p]; const [sx2, sy2] = toXY(t.x, t.y); ctx.fillStyle='#e8eaed'; ctx.beginPath(); ctx.arc(sx2, sy2, 2.0, 0, Math.PI*2); ctx.fill();
  }
}

function stats(){
  const speed = sim.tracers.reduce((a,t)=>a+Math.hypot(t.vx, t.vy),0)/Math.max(1, sim.tracers.length);
  byId('stats').textContent = `cells: ${sim.total}  ciliated: ${sim.totalCiliated}\ntracers: ${sim.tracers.length}  avg|v|≈ ${speed.toFixed(3)}`;
}

// ===== Lifecycle =====
function rebuild(){ generateGrid(); reseedAngles(); buildSources(); updateVoronoi(); seedTracers(); draw(); stats(); updateScaleBar(); }
function loop(){ if (sim.playing){ sim.time += params.dt; step(params.dt); draw(); stats(); updateScaleBar(); } requestAnimationFrame(loop); }

// boot
function boot(){
  sim.canvas = byId('canvas'); sim.ctx = sim.canvas.getContext('2d', { alpha:false });
  window.addEventListener('resize', ()=>{ resizeCanvas(); draw(); }); connect(); resizeCanvas(); rebuild(); loop();
}
boot();

// ===== Preset mapping (derived from MATLAB script) =====
// Physical constants for D (same as MATLAB)
const C2K = 273.15; const kB = 1.380649E-23; // [m2 kg s-1 K-1]
const mu20 = 1.0016E-3, mu25 = 0.89E-3, mu37 = 0.6913E-3; // [Pa s]
// (L0, L0m) defined above for early availability
const rTracer = 0.5E-6; // [m]
function D_at_T(mu){ return kB*(C2K+20)/ (6*Math.PI*mu*rTracer); }
const D20 = D_at_T(mu20), D25 = kB*(C2K+25)/(6*Math.PI*mu25*rTracer), D37 = kB*(C2K+37)/(6*Math.PI*mu37*rTracer);

// Measured CBF [Hz]
const CBF_human = [2.743333333, 3.5, 2.683706];
const CBF_rat = [3.09, 4.1, 6.31, 4.65, 4.61, 6.23, 3.33];
const CBF_BD = [10.65, 14.79, 16.2, 14.65, 14.63];
const CBF_mAir = [17.77, 18.09, 16.26, 16.66];
const CBF_PC = [6.33, 14.39, 16.29, 15.98, 13.95];
const CBF_PCS = [14.79, 14.8, 16.26, 14.6];
const CBF_SAGM = [14.64];

// Ex vivo/in vitro measurements (μm) or unitless
const human_h = [7.06,6.57,7.17,7.71,7.23,7.24,7.71];
const human_ap= [13.45,11.04,13.58,10.93333333];
const human_oop=[0.82,0.87,0.96];
const human_cop=[0.755255328,0.596899225,0.927536232,0.699680511,0.820220936];
const human_lam=[26.89,25.80,31.30,24.80,36.33333333].map(x=>x/L0);

const rat_h = [6.383];
const rat_ap= [8.89, 7.99, 6.45, 6.05, 6.9, 6.5];
const rat_oop=[0.51,0.53,0.55,0.87,0.87,0.60,0.14,0.45,0.25];
const rat_cop=[0.66004415,0.730042693,0.923790973,0.6,0.614035088,0.666666667,0.573770492];
const rat_lam=[30.5,36,22.65,30,19.9,28,28.5].map(x=>x/L0);

const bd_h = [.546,.508,.714,.606].map(x=>x*L0); // μm
const bd_ap=[1.03,1.03,.750,.893].map(x=>x*L0);
const bd_oop=[.624,.834,.809,.9];
const bd_cop=[.713,.471,.837,.77];
// Using pcs_lam for pc_pr in MATLAB; reuse mapping per script
const pc_h = [.651,.752,.697,.699].map(x=>x*L0);
const pc_ap=[1.25,1.16,1.43,1.092].map(x=>x*L0);
const pc_oop=[.739,.644,.897,.24];
const pc_cop=[.837,.767,.841,.5];

const pcs_h=[.746,.744,.899,.679].map(x=>x*L0);
const pcs_ap=[.692,.766,.773,.649].map(x=>x*L0);
const pcs_oop=[.716,.792,.704,.77];
const pcs_cop=[.749,.84,.879,.86];

const sagm_h=[.688].map(x=>x*L0);
const sagm_ap=[.742].map(x=>x*L0);
const sagm_oop=[.7];
const sagm_cop=[.77];

const mair_h=[.628,.634,.784,.63].map(x=>x*L0);
const mair_ap=[.934,.851,.616,.836].map(x=>x*L0);
const mair_oop=[.716,.706,.849,.65];
const mair_cop=[.626,.578,.932,.5];

const bd_lam = avg([17.5,24.63,18.5,37.25])/L0;
const pc_lam = avg([14.63,13,13.25,25.48])/L0;
const pcs_lam = avg([14.88,15.63,14,22.02])/L0;
const sagm_lam = avg([23.43])/L0;
const mair_lam = avg([15.38,22,17,29.67])/L0;

function avg(arr){ return arr.reduce((a,b)=>a+b,0)/arr.length; }
function minA(arr){ return arr.reduce((a,b)=>Math.min(a,b), Infinity); }
function maxA(arr){ return arr.reduce((a,b)=>Math.max(a,b), -Infinity); }
function kaFromOOP(oop){ return Math.sqrt(-Math.log(oop)/2); }
function prFromCOPandLam(cop, lam){ return (1-avg(cop))*lam/Math.SQRT2; }
function deg(rad){ return rad*180/Math.PI; }

function setPresetParams({h, ap, sigma, pr, lambda, D, coverage}){
  params.ciliaH = h; params.amp = ap; params.angleStdDeg = deg(sigma);
  // map pr to our crystalline jitter
  params.crystalline = pr; params.patchlength = lambda/Math.max(2, Math.floor(params.nX));
  if (typeof D === 'number') params.diff = D;
  if (typeof coverage === 'number') params.coverage = coverage;
}

function applyPreset(name){
  // Defaults shared
  const nX = Math.max(2, Math.floor(params.nX));
  if (name === 'example'){
    const lambda = 30/L0; const sigma = 0.1978987; const pr = 0; setPresetParams({ h: 10/L0, ap: 10/L0, sigma, pr, lambda, D: 0.01, coverage: 0.5 }); return;
  }
  function D_for(cbfArr, Dref){ const meanCBF = avg(cbfArr); return Dref/meanCBF/(L0m*L0m); }
  // Precompute D’s
  const Dhuman = D_for(CBF_human, D20), Drat = D_for(CBF_rat, D20);
  const DbdMax = (1e-12)/maxA(CBF_BD)/(L0m*L0m); const Dbd = (6e-12)/avg(CBF_BD)/(L0m*L0m); const DbdMin = (30e-12)/minA(CBF_BD)/(L0m*L0m);
  const DmairMax=(10e-12)/maxA(CBF_mAir)/(L0m*L0m); const Dmair=(17e-12)/avg(CBF_mAir)/(L0m*L0m); const DmairMin=(33e-12)/minA(CBF_mAir)/(L0m*L0m);
  const DpcMax=(15e-12)/maxA(CBF_PC)/(L0m*L0m); const Dpc=(28e-12)/avg(CBF_PC)/(L0m*L0m); const DpcMin=(42e-12)/minA(CBF_PC)/(L0m*L0m);
  const DpcsMax=(2e-12)/maxA(CBF_PCS)/(L0m*L0m); const Dpcs=(10e-12)/avg(CBF_PCS)/(L0m*L0m); const DpcsMin=(28e-12)/minA(CBF_PCS)/(L0m*L0m);
  const DsagmMax=(5e-12)/maxA(CBF_SAGM)/(L0m*L0m); const Dsagm=(9e-12)/avg(CBF_SAGM)/(L0m*L0m); const DsagmMin=(18e-12)/minA(CBF_SAGM)/(L0m*L0m);

  // helper to set from dataset
  function setFrom(hArr, apArr, oopArr, copArr, lamVal, Dval, prLamVal){
    const sigma = kaFromOOP(avg(oopArr || [1]));
    const pr = prFromCOPandLam(copArr || [1], prLamVal ?? lamVal);
    setPresetParams({ h: avg(hArr)/L0, ap: avg(apArr)/L0, sigma, pr, lambda: lamVal, D: Dval, coverage: 0.5 });
  }

  switch(name){
    // === Example 1–8: combinations of (coverage, sigma, prand) ===
    case 'example1': applyExamplePreset({cov:'low', sig:'low', pr:'low'}); return;
    case 'example2': applyExamplePreset({cov:'high',sig:'low', pr:'low'}); return;
    case 'example3': applyExamplePreset({cov:'low', sig:'high',pr:'low'}); return;
    case 'example4': applyExamplePreset({cov:'high',sig:'high',pr:'low'}); return;
    case 'example5': applyExamplePreset({cov:'low', sig:'low', pr:'high'}); return;
    case 'example6': applyExamplePreset({cov:'high',sig:'low', pr:'high'}); return;
    case 'example7': applyExamplePreset({cov:'low', sig:'high',pr:'high'}); return;
    case 'example8': applyExamplePreset({cov:'high',sig:'high',pr:'high'}); return;
    case 'human_avg': setFrom(human_h, human_ap, human_oop, human_cop, avg(human_lam), Dhuman); break;
    case 'human_max': setFrom([maxA(human_h)], [maxA(human_ap)], [maxA(human_oop)], human_cop, avg(human_lam), Dhuman); break;
    case 'human_min': setFrom([minA(human_h)], [minA(human_ap)], [minA(human_oop)], human_cop, avg(human_lam), Dhuman); break;
    case 'rat_avg': setFrom(rat_h, rat_ap, rat_oop, rat_cop, avg(rat_lam), Drat); break;
    case 'rat_max': setFrom([maxA(rat_h)], [maxA(rat_ap)], [maxA(rat_oop)], rat_cop, avg(rat_lam), Drat); break;
    case 'rat_min': setFrom([minA(rat_h)], [minA(rat_ap)], [minA(rat_oop)], rat_cop, avg(rat_lam), Drat); break;
    case 'bd_avg': setFrom(bd_h, bd_ap, bd_oop, bd_cop, bd_lam, Dbd); break;
    case 'bd_max': setFrom([maxA(bd_h)], [maxA(bd_ap)], [minA(bd_oop)], bd_cop, bd_lam, DbdMax); break;
    case 'bd_min': setFrom([minA(bd_h)], [minA(bd_ap)], [maxA(bd_oop)], bd_cop, bd_lam, DbdMin); break;
    case 'mair_avg': setFrom(mair_h, mair_ap, mair_oop, mair_cop, mair_lam, Dmair); break;
    case 'mair_max': setFrom([maxA(mair_h)], [maxA(mair_ap)], [minA(mair_oop)], mair_cop, mair_lam, DmairMax); break;
    case 'mair_min': setFrom([minA(mair_h)], [minA(mair_ap)], [maxA(mair_oop)], mair_cop, mair_lam, DmairMin); break;
    case 'pc_avg': setFrom(pc_h, pc_ap, pc_oop, pc_cop, pc_lam, Dpc, pcs_lam); break;
    case 'pc_max': setFrom([maxA(pc_h)], [maxA(pc_ap)], [minA(pc_oop)], pc_cop, pc_lam, DpcMax, pcs_lam); break;
    case 'pc_min': setFrom([minA(pc_h)], [minA(pc_ap)], [maxA(pc_oop)], pc_cop, pc_lam, DpcMin, pcs_lam); break;
    case 'pcs_avg': setFrom(pcs_h, pcs_ap, pcs_oop, pcs_cop, pcs_lam, Dpcs, sagm_lam); break;
    case 'pcs_max': setFrom([maxA(pcs_h)], [maxA(pcs_ap)], [minA(pcs_oop)], pcs_cop, pcs_lam, DpcsMax, sagm_lam); break;
    case 'pcs_min': setFrom([minA(pcs_h)], [minA(pcs_ap)], [maxA(pcs_oop)], pcs_cop, pcs_lam, DpcsMin, sagm_lam); break;
    case 'sagm_avg': setFrom(sagm_h, sagm_ap, sagm_oop, sagm_cop, sagm_lam, Dsagm, mair_lam); break;
    case 'sagm_max': setFrom([maxA(sagm_h)], [maxA(sagm_ap)], [minA(sagm_oop)], sagm_cop, sagm_lam, DsagmMax, mair_lam); break;
    case 'sagm_min': setFrom([minA(sagm_h)], [minA(sagm_ap)], [maxA(sagm_oop)], sagm_cop, sagm_lam, DsagmMin, mair_lam); break;
    case 'pc_atp': {
      // amplitude multiplier
      const ap_mul=[1.303708011,1.787539856,1.43213827]; const ap_adj = pc_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)); setFrom(pc_h, ap_adj, pc_oop, pc_cop, pc_lam, Dpc, pcs_lam); break;
    }
    case 'pc_atp_max': { const ap_mul=[1.303708011,1.787539856,1.43213827]; const ap_adj = [maxA(pc_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)))]; setFrom([maxA(pc_h)], ap_adj, [minA(pc_oop)], pc_cop, pc_lam, DpcMax, pcs_lam); break; }
    case 'pc_atp_min': { const ap_mul=[1.303708011,1.787539856,1.43213827]; const ap_adj = [minA(pc_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)))]; setFrom([minA(pc_h)], ap_adj, [maxA(pc_oop)], pc_cop, pc_lam, DpcMin, pcs_lam); break; }
    case 'pcs_atp': {
      const ap_mul=[1.303708011,1.787539856,1.43213827]; const ap_adj = pcs_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)); setFrom(pcs_h, ap_adj, pcs_oop, pcs_cop, pcs_lam, Dpcs); break;
    }
    case 'pcs_atp_max': { const ap_mul=[1.303708011,1.787539856,1.43213827]; const ap_adj = [maxA(pcs_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)))]; setFrom([maxA(pcs_h)], ap_adj, [minA(pcs_oop)], pcs_cop, pcs_lam, DpcsMax); break; }
    case 'pcs_atp_min': { const ap_mul=[1.303708011,1.787539856,1.43213827]; const ap_adj = [minA(pcs_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)))]; setFrom([minA(pcs_h)], ap_adj, [maxA(pcs_oop)], pcs_cop, pcs_lam, DpcsMin); break; }
    case 'pc_muc': {
      const ap_mul=[1.106630469,1.216907924,1.079506873]; const ap_adj = pc_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)); setFrom(pc_h, ap_adj, pc_oop, pc_cop, pc_lam, Dpc, pcs_lam); break;
    }
    case 'pc_muc_max': { const ap_mul=[1.106630469,1.216907924,1.079506873]; const ap_adj = [maxA(pc_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)))]; setFrom([maxA(pc_h)], ap_adj, [minA(pc_oop)], pc_cop, pc_lam, DpcMax, pcs_lam); break; }
    case 'pc_muc_min': { const ap_mul=[1.106630469,1.216907924,1.079506873]; const ap_adj = [minA(pc_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)))]; setFrom([minA(pc_h)], ap_adj, [maxA(pc_oop)], pc_cop, pc_lam, DpcMin, pcs_lam); break; }
    case 'pcs_muc': {
      const ap_mul=[1.106630469,1.216907924,1.079506873]; const ap_adj = pcs_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)); setFrom(pcs_h, ap_adj, pcs_oop, pcs_cop, pcs_lam, Dpcs); break;
    }
    case 'pcs_muc_max': { const ap_mul=[1.106630469,1.216907924,1.079506873]; const ap_adj = [maxA(pcs_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)))]; setFrom([maxA(pcs_h)], ap_adj, [minA(pcs_oop)], pcs_cop, pcs_lam, DpcsMax); break; }
    case 'pcs_muc_min': { const ap_mul=[1.106630469,1.216907924,1.079506873]; const ap_adj = [minA(pcs_ap.map((v,i)=>v*(ap_mul[i%ap_mul.length]||1)))]; setFrom([minA(pcs_h)], ap_adj, [maxA(pcs_oop)], pcs_cop, pcs_lam, DpcsMin); break; }
    case 'pc_D37': setFrom(pc_h, pc_ap, pc_oop, pc_cop, pc_lam, D_for(CBF_PC, D37)); break;
    default: break;
  }
}

function syncUIFromParams(){
  const pairs = ['nX','nY','spacing','coverage','patchlength','crystalline','patchorder','angleStd','ciliaH','amp','eps','diff','dt','nTracer','trail'];
  for (const id of pairs){ const key = (id==='angleStd')? 'angleStdDeg' : id; setSlider(id, params[key]); }
}

// Helper for example 1–8 from MATLAB comments
function applyExamplePreset({cov, sig, pr}){
  const covVal = (cov==='high') ? 0.8 : 0.5;
  const sigmaRad = (sig==='high') ? 0.83527 : 0.1978987;
  const prandVal = (pr==='high') ? 1.06066 : 0.0;
  params.coverage = covVal;
  params.angleStdDeg = sigmaRad * 180/Math.PI;
  params.crystalline = prandVal;
  params.ciliaH = 1.0; params.amp = 1.0; params.diff = 0.01;
  const lambda = 30 / L0; // 30um/L0
  const nX = Math.max(2, Math.floor(params.nX));
  params.patchlength = lambda / nX;
}

// ===== Scale bar =====
function updateScaleBar(){
  const bar = document.getElementById('bar'); const label = document.getElementById('barlabel'); if (!bar||!label) return;
  const um = Math.max(0.5, Number(params.barum) || 10);
  const world = um / L0; // convert μm to world units
  const px = world * sim.scale;
  bar.style.width = `${Math.max(4, px)}px`;
  label.textContent = `${um.toFixed(0)} μm`;
}

// ===== Modifiers (modList) =====
const humanKaAvg = Math.sqrt(-Math.log((human_oop.reduce((a,b)=>a+b,0)/human_oop.length))/2);
const human_pr = prFromCOPandLam(human_cop, human_lam.reduce((a,b)=>a+b,0)/human_lam.length);
const human_lambda_avg = human_lam.reduce((a,b)=>a+b,0)/human_lam.length;
function applyMod(name){
  switch(name){
    case 'human_h':
      params.ciliaH = human_h.reduce((a,b)=>a+b,0)/human_h.length / L0; break;
    case 'human_ap':
      params.amp = human_ap.reduce((a,b)=>a+b,0)/human_ap.length / L0; break;
    case 'human_oop':
      params.angleStdDeg = (Math.sqrt(-Math.log(human_oop.reduce((a,b)=>a+b,0)/human_oop.length)/2))*180/Math.PI; break;
    case 'human_diff':
      params.diff = (kB*(C2K+37)/(6*Math.PI*mu37*rTracer)) / (CBF_human.reduce((a,b)=>a+b,0)/CBF_human.length) / (L0m*L0m); break;
    case 'human_not_h':
      params.amp = human_ap.reduce((a,b)=>a+b,0)/human_ap.length / L0; params.angleStdDeg = (Math.sqrt(-Math.log(human_oop.reduce((a,b)=>a+b,0)/human_oop.length)/2))*180/Math.PI; params.crystalline = human_pr; params.patchlength = human_lambda_avg/Math.max(2, Math.floor(params.nX)); break;
    case 'human_not_ap':
      params.ciliaH = human_h.reduce((a,b)=>a+b,0)/human_h.length / L0; params.angleStdDeg = (Math.sqrt(-Math.log(human_oop.reduce((a,b)=>a+b,0)/human_oop.length)/2))*180/Math.PI; params.crystalline = human_pr; params.patchlength = human_lambda_avg/Math.max(2, Math.floor(params.nX)); break;
    case 'human_not_oop':
      params.ciliaH = human_h.reduce((a,b)=>a+b,0)/human_h.length / L0; params.amp = human_ap.reduce((a,b)=>a+b,0)/human_ap.length / L0; params.crystalline = human_pr; params.patchlength = human_lambda_avg/Math.max(2, Math.floor(params.nX)); break;
    case 'human_not_diff':
      params.ciliaH = human_h.reduce((a,b)=>a+b,0)/human_h.length / L0; params.amp = human_ap.reduce((a,b)=>a+b,0)/human_ap.length / L0; params.angleStdDeg = (Math.sqrt(-Math.log(human_oop.reduce((a,b)=>a+b,0)/human_oop.length)/2))*180/Math.PI; params.crystalline = human_pr; params.patchlength = human_lambda_avg/Math.max(2, Math.floor(params.nX)); break;
    default: break;
  }
}
</script>
</body>
</html>


<!-- %% characteristic scales 
mu = 1; % dimensionless viscosity (characteristic 'force' scale)
CBF = 1; % dimensionless CBF (characteristic time scale)
spacing = 1; % dimensionless distance between cells (characteristic length scale)

L0 = 10; % typical cell size in [um]
L0m = 10E-6; % typical cell size in [m]

% viscosity of water at different temperature
mu20 = 1.0016E-3; % [Pa s] or [kg m-1 s-1]
mu25 = 0.89E-3; % [Pa s] or [kg m-1 s-1]
mu37 = 0.6913E-3; % [Pa s] or [kg m-1 s-1]

C2K = 273.15; % Celcius to Kelvin

r = 0.5E-6; % tracer radius [m]

kB = 1.380649E-23; % Boltzmann constant [m2 kg s-1 K-1]

% CBF of measured ex Vivo samples [Hz]
% H2924, H44, H47
CBF_human = [2.743333333, 3.5, 2.683706];
% TUMR55, TUMR56, USCR42 TUMR55 USCR43 USCR43 TUMR56
CBF_rat = [3.09 4.1 6.31 4.65 4.61 6.23 3.33];

% CBF of measured in Vitro samples [Hz]
CBF_BD = ([
  10.65; %H47
  14.79; %HB6288
  16.2 %8265
  14.65 %7783
  14.63]); %8938

CBF_mAir = ([
  17.77; %HB6288
  18.09 %8265
  16.26 %7783
  16.66]); %8938

CBF_PC = ([6.33 %H47
  14.39 %HB8265
  16.29 %7783
  15.98 %8938
  13.95]); %6288

CBF_PCS = ([
  14.79; %HB6288
  14.8 %8265
  16.26 %7783
  14.6]); %8938

CBF_SAGM = ([14.64]); %8938

% diffusion coefficient of tracer in water at specified temperature
D20 = kB*(C2K+20)/6/pi/mu20/r; % [m2 s-1]
D25 = kB*(C2K+25)/6/pi/mu25/r; % [m2 s-1]
D37 = kB*(C2K+37)/6/pi/mu37/r; % [m2 s-1]

% diffusion coefficient in dimensionless unit / Peclet number
Dhuman = D20/mean(CBF_human)/(L0m)^2;
Drat = D20/mean(CBF_rat)/(L0m)^2;

% empirical dimensionless diffusion coefficient from tracks (median)
% Dhuman = 0.28e-12/mean(CBF_human)/(L0m)^2; % similar to theoretical calculations above
% Drat = 0.07e-12/mean(CBF_rat)/(L0m)^2; % probablematic due to track quanlity

DbdMax = 1e-12/max(CBF_BD)/(L0m)^2;
Dbd = 6e-12/mean(CBF_BD)/(L0m)^2;
DbdMin = 30e-12/min(CBF_BD)/(L0m)^2;

DmairMax = 10e-12/max(CBF_mAir)/(L0m)^2;
Dmair = 17e-12/mean(CBF_mAir)/(L0m)^2;
DmairMin = 33e-12/min(CBF_mAir)/(L0m)^2;

DpcMax = 15e-12/max(CBF_PC)/(L0m)^2;
Dpc = 28e-12/mean(CBF_PC)/(L0m)^2;
DpcMin = 42e-12/min(CBF_PC)/(L0m)^2;

Dpc_D37 = D37/mean(CBF_PC)/(L0m)^2;

DpcsMax = 2e-12/max(CBF_PCS)/(L0m)^2;
Dpcs = 10e-12/mean(CBF_PCS)/(L0m)^2;
DpcsMin = 28e-12/min(CBF_PCS)/(L0m)^2;

DsagmMax = 5e-12/max(CBF_SAGM)/(L0m)^2;
Dsagm = 9e-12/mean(CBF_SAGM)/(L0m)^2;
DsagmMin = 18e-12/min(CBF_SAGM)/(L0m)^2;

%% ex vivo sample measurements
% (h = cilia length, ap = beat amplitude, oop = beat order, cop = crystalline order)

% BR640 BR641 BR643 BR644 BR646 BR648 BR650 BR652
human_h = [7.06;6.57;7.17;7.71;7.23;7.24;7.71];
% H47 H47 H48 H2924
human_ap = [13.45 11.04 13.58 10.93333333]; 
% % H44 H47 H47 H48 H48 H2924
% human_oop = [0.91 0.95 0.93 .92 .92 .96];
% H44 H47 H2924 (Benchmark FOV only)
human_oop = [0.82 0.87 0.96];
% H44 H47 H47 H48 H2924
human_cop = [0.755255328 0.596899225 0.927536232 0.699680511 0.820220936];

rat_h = 6.383; % USCR10
% USCR42 USCR43 TUMR56 TUMR56 TUMR55 TUMR55
rat_ap = [8.89 7.99 6.45 6.05 6.9 6.5];
% USCR42 USCR43 USCR43 TUMR01 TUMR02 TUMR56 TUMR56 TUMR55 TUMR55
rat_oop = [0.51 0.53 0.55 0.87 0.87 0.60 0.14 0.45 0.25];
% USCR42 USCR43 TUMR01 TUMR02 TUMR56 TUMR56 TUMR55
rat_cop	= [0.66004415 0.730042693 0.923790973 0.6 0.614035088 0.666666667 0.573770492];

%% in vitro sample measurements (HB7783 HB8265 HB8938 HB6288)
% (h = cilia length, ap = beat amplitude, oop = beat order, cop = crystalline order)
bd_h = [.546 .508 .714 .606]*L0; %um
bd_ap = [1.03 1.03 .750 .893]*L0; %um
bd_oop = [.624 .834 .809 .9];
bd_cop = [.713 .471 .837 .77];
	
pc_h = [.651 .752 .697 .699]*L0; %um
pc_ap = [1.25 1.16 1.43 1.092]*L0; %um
pc_oop = [.739 .644 .897 .24];
pc_cop = [.837 .767 .841 .5];

pcs_h = [.746 .744 .899 .679]*L0; %um
pcs_ap = [.692 .766 .773 .649]*L0; %um
pcs_oop = [.716 .792 .704 .77];
pcs_cop = [.749 .84 .879 .86];

% 8265, 7783, 6288 did not differentiate
sagm_h = [.688]*L0; %um
sagm_ap = [.742]*L0; %um
sagm_oop = [.7];
sagm_cop = [.77];

mair_h = [.628 .634 .784 .63]*L0; %um
mair_ap = [.934 .851 .616 .836]*L0; %um
mair_oop = [.716 .706 .849 .65];
mair_cop = [.626 .578 .932 .5];

% modifiers for beat amplitude in mucus and with atp
ap_pcs_mucus = [1.106630469 1.216907924 1.079506873];

ap_pcs_atp = [1.303708011 1.787539856 1.43213827];

%% convert beat order parameter (OOP) to wrapped normal standard deviation
humanKaMin = sqrt(-log(min(human_oop))/2);
humanKaAvg = sqrt(-log(mean(human_oop))/2);
humanKaMax = sqrt(-log(max(human_oop))/2);

ratKaMin = sqrt(-log(min(rat_oop))/2);
ratKaAvg = sqrt(-log(mean(rat_oop))/2);
ratKaMax = sqrt(-log(max(rat_oop))/2);

bdKa = sqrt(-log(bd_oop)/2);
mairKa = sqrt(-log(mair_oop)/2);
pcKa = sqrt(-log(pc_oop)/2);
pcsKa = sqrt(-log(pcs_oop)/2);
sagmKa = sqrt(-log(sagm_oop)/2);

%% convert crystalline order parameter and patch wavelength to simulation parameter
% ex vivo patch wavelength / lambda
% H44 H47 H48 H48 H2924
human_lam = [26.89, 25.80, 31.30, 24.80, 36.33333333]/L0;
% TUMR55 TUMR56 USCR42 TUMR55 USCR43 USCR43 TUMR56
rat_lam = [30.5, 36, 22.65, 30, 19.9, 28, 28.5]/L0;

% simulation order parameter for square lattice
human_pr = (1-mean(human_cop))*mean(human_lam)/sqrt(2);
rat_pr = (1-mean(rat_cop))*mean(rat_lam)/sqrt(2);

% in vitro patch wavelength / lambda (7783 8265 8938 6288)
bd_lam = mean([17.5 24.63 18.5 37.25])/L0;
pc_lam = mean([14.63 13 13.25 25.48])/L0;
pcs_lam = mean([14.88 15.63 14 22.02])/L0;
sagm_lam = mean([23.43])/L0; % 8265, 7783, 6288 did not differentiate
mair_lam = mean([15.38 22 17 29.67])/L0;

% simulation order parameter for square lattice
bd_pr = (1-mean(bd_cop))*(bd_lam)/sqrt(2);
pc_pr = (1-mean(pc_cop))*(pcs_lam)/sqrt(2);
pcs_pr = (1-mean(pcs_cop))*(sagm_lam)/sqrt(2);
sagm_pr = (1-mean(sagm_cop))*(mair_lam)/sqrt(2);
mair_pr = (1-mean(mair_cop))*(pc_lam)/sqrt(2);

%% other simulation parameters
nX = 51; nY = nX; nCell = nX*nY; % number of cells in periodic domain
randness = 1/2; % dimensionless rectangular grid perturbation
bd = spacing/10; % dimensionless regularization parameter
dragCoeff = mu*CBF*spacing; % effective dimensionless drag per cell per beat


switch caseName
  case 'example'
    nX = 21; nY = nX; nCell = nX*nY;
    h = 10/L0; % 10um
    ap = 10/L0; % 10um
    sigma = [0.1978987 0.83527]; % oop 0.9 0.3
    pRand = [0 1.06066]; % cop 1 0.5
    lambda = 30/L0; % 30um periodic patches
    D = 0.01;
    pCilia = [0.5 0.8];
    Npar = 40;
    Nt = 300;
  case 'human_max'
    h = max(human_h)/L0;
    ap = max(human_ap)/L0;
    sigma = humanKaMax;
    pRand = human_pr;
    lambda = mean(human_lam);
    D = Dhuman;
  case 'human_min'
    h = min(human_h)/L0;
    ap = min(human_ap)/L0;
    sigma = humanKaMin;
    pRand = human_pr;
    lambda = mean(human_lam);
    D = Dhuman;
  case 'human_avg'
    h = mean(human_h)/L0;
    ap = mean(human_ap)/L0;
    sigma = humanKaAvg;
    pRand = human_pr;
    lambda = mean(human_lam);
    D = Dhuman;
  case 'rat_max'
    h = max(rat_h)/L0;
    ap = max(rat_ap)/L0;
    sigma = ratKaMax;
    pRand = rat_pr;
    lambda = mean(rat_lam);
    D = Drat;
  case 'rat_avg'
    h = mean(rat_h)/L0;
    ap = mean(rat_ap)/L0;
    sigma = ratKaAvg;
    pRand = rat_pr;
    lambda = mean(rat_lam);
    D = Drat;
  case 'rat_min'
    h = min(rat_h)/L0;
    ap = min(rat_ap)/L0;
    sigma = ratKaMin;
    pRand = rat_pr;
    lambda = mean(rat_lam);
    D = Drat;
  case 'bd_avg'
    h = mean(bd_h)/L0;
    ap = mean(bd_ap)/L0;
    sigma = mean(bdKa);
    pRand = bd_pr;
    lambda = bd_lam;
    D = Dbd;
  case 'bd_max'
    h = max(bd_h/L0);
    ap = max(bd_ap/L0);
    sigma = min(bdKa);
    pRand = bd_pr;
    lambda = bd_lam;
    D = DbdMax;
  case 'bd_min'
    h = min(bd_h/L0);
    ap = min(bd_ap/L0);
    sigma = max(bdKa);
    pRand = bd_pr;
    lambda = bd_lam;
    D = DbdMin;
  case 'mair_avg'
    h = mean(mair_h)/L0;
    ap = mean(mair_ap)/L0;
    sigma = mean(mairKa);
    pRand = mair_pr;
    lambda = mair_lam;
    D = Dmair;
  case 'mair_max'
    h = max(mair_h/L0);
    ap = max(mair_ap/L0);
    sigma = min(mairKa);
    pRand = mair_pr;
    lambda = mair_lam;
    D = DmairMax;
  case 'mair_min'
    h = min(mair_h/L0);
    ap = min(mair_ap/L0);
    sigma = max(mairKa);
    pRand = mair_pr;
    lambda = mair_lam;
    D = DmairMin;
  case 'pc_D37'
    h = mean(pc_h)/L0;
    ap = mean(pc_ap)/L0;
    sigma = mean(pcKa);
    pRand = pc_pr;
    lambda = pc_lam;
    D = Dpc_D37;
  case 'pc_avg'
    h = mean(pc_h)/L0;
    ap = mean(pc_ap)/L0;
    sigma = mean(pcKa);
    pRand = pc_pr;
    lambda = pc_lam;
    D = Dpc;
  case 'pc_max'
    h = max(pc_h/L0);
    ap = max(pc_ap/L0);
    sigma = min(pcKa);
    pRand = pc_pr;
    lambda = pc_lam;
    D = DpcMax;
  case 'pc_min'
    h = min(pc_h/L0);
    ap = min(pc_ap/L0);
    sigma = max(pcKa);
    pRand = pc_pr;
    lambda = pc_lam;
    D = DpcMin;
  case 'pcs_avg'
    h = mean(pcs_h)/L0;
    ap = mean(pcs_ap)/L0;
    sigma = mean(pcsKa);
    pRand = pcs_pr;
    lambda = pcs_lam;
    D = Dpcs;
  case 'pcs_max'
    h = max(pcs_h/L0);
    ap = max(pcs_ap/L0);
    sigma = min(pcsKa);
    pRand = pcs_pr;
    lambda = pcs_lam;
    D = DpcsMax;
  case 'pcs_min'
    h = min(pcs_h/L0);
    ap = min(pcs_ap/L0);
    sigma = max(pcsKa);
    pRand = pcs_pr;
    lambda = pcs_lam;
    D = DpcsMin;
  case 'sagm_avg'
    h = mean(sagm_h)/L0;
    ap = mean(sagm_ap)/L0;
    sigma = mean(sagmKa);
    pRand = sagm_pr;
    lambda = sagm_lam;
    D = Dsagm;
  case 'sagm_max'
    h = max(sagm_h/L0);
    ap = max(sagm_ap/L0);
    sigma = min(sagmKa);
    pRand = sagm_pr;
    lambda = sagm_lam;
    D = DsagmMax;
  case 'sagm_min'
    h = min(sagm_h/L0);
    ap = min(sagm_ap/L0);
    sigma = max(sagmKa);
    pRand = sagm_pr;
    lambda = sagm_lam;
    D = DsagmMin;
  case 'pc_atp'
    h = mean(pc_h)/L0;
    tmp = pc_ap.*ap_pcs_atp;
    ap = mean(tmp(:))/L0;
    sigma = mean(pcKa);
    pRand = pc_pr;
    lambda = pc_lam;
    D = Dpc;
  case 'pc_atp_max'
    h = max(pc_h)/L0;
    tmp = pc_ap.*ap_pcs_atp;
    ap = max(tmp(:))/L0;
    sigma = min(pcKa);
    pRand = pc_pr;
    lambda = pc_lam;
    D = DpcMax;
  case 'pc_atp_min'
    h = min(pc_h)/L0;
    tmp = pc_ap.*ap_pcs_atp;
    ap = min(tmp(:))/L0;
    sigma = max(pcKa);
    pRand = pc_pr;
    lambda = pc_lam;
    D = DpcMin;
  case 'pcs_atp'
    h = mean(pcs_h)/L0;
    tmp = pcs_ap.*ap_pcs_atp;
    ap = mean(tmp(:))/L0;
    sigma = mean(pcsKa);
    pRand = pcs_pr;
    lambda = pcs_lam;
    D = Dpcs;
  case 'pcs_atp_max'
    h = max(pcs_h)/L0;
    tmp = pcs_ap.*ap_pcs_atp;
    ap = max(tmp(:))/L0;
    sigma = min(pcsKa);
    pRand = pcs_pr;
    lambda = pcs_lam;
    D = DpcsMax;
  case 'pcs_atp_min'
    h = min(pcs_h)/L0;
    tmp = pcs_ap.*ap_pcs_atp;
    ap = min(tmp(:))/L0;
    sigma = max(pcsKa);
    pRand = pcs_pr;
    lambda = pcs_lam;
    D = DpcsMin;
  case 'pc_muc'
    h = mean(pc_h)/L0;
    tmp = pc_ap.*ap_pcs_mucus;
    ap = mean(tmp(:))/L0;
    sigma = mean(pcKa);
    pRand = pc_pr;
    lambda = pc_lam;
    D = Dpc;
  case 'pc_muc_max'
    h = max(pc_h)/L0;
    tmp = pc_ap.*ap_pcs_mucus;
    ap = max(tmp(:))/L0;
    sigma = min(pcKa);
    pRand = pc_pr;
    lambda = pc_lam;
    D = DpcMax;
  case 'pc_muc_min'
    h = min(pc_h)/L0;
    tmp = pc_ap.*ap_pcs_mucus;
    ap = min(tmp(:))/L0;
    sigma = max(pcKa);
    pRand = pc_pr;
    lambda = pc_lam;
    D = DpcMin;
  case 'pcs_muc'
    h = mean(pcs_h)/L0;
    tmp = pcs_ap.*ap_pcs_mucus;
    ap = mean(tmp(:))/L0;
    sigma = mean(pcsKa);
    pRand = pcs_pr;
    lambda = pcs_lam;
    D = Dpcs;
  case 'pcs_muc_max'
    h = max(pcs_h)/L0;
    tmp = pcs_ap.*ap_pcs_mucus;
    ap = max(tmp(:))/L0;
    sigma = min(pcsKa);
    pRand = pcs_pr;
    lambda = pcs_lam;
    D = DpcsMax;
  case 'pcs_muc_min'
    h = min(pcs_h)/L0;
    tmp = pcs_ap.*ap_pcs_mucus;
    ap = min(tmp(:))/L0;
    sigma = max(pcsKa);
    pRand = pcs_pr;
    lambda = pcs_lam;
    D = DpcsMin;
  case 'hVar'
    h = .4:.2:1; % cilia tip height scaling
    ap = 1; % 10um
    sigma = .5;
    pRand = 1;
    lambda = 30/L0; % 30um periodic patches
    D = 0.001;
  case 'aVar'
    h = 1;
    ap = [.5 .8 1 1.5]; % beat amplitude scaling
    sigma = .5;
    pRand = 1;
    lambda = 30/L0; % 30um periodic patches
    D = 0.001;
  case 'kVar'
    h = 1; % 10um
    ap = 1; % 10um
    sigma = [.1 .2 .5 1]; % alignment scaling
    pRand = 1;
    lambda = 30/L0; % 30um periodic patches
    D = 0.001;
  case 'pVar'
    h = 1; % 10um
    ap = 1; % 10um
    sigma = .5;
    pRand = [0 .5 1 2]; % position variation scaling
    lambda = 30/L0; % 30um periodic patches
    D = 0.001;
  case 'diffVar'
    h = 1; % 10um
    ap = 1; % 10um
    sigma = .5;
    pRand = .5;
    lambda = 30/L0; % 30um periodic patches
    D = [0.001 0.01 0.1];
  otherwise
    error('invalid case study name!!!');
end


%%
switch modList{modi}
  case 'human_h'
    h = mean(human_h/L0);
    fprintf(['Except using human benchmark (avg) height...\n']);
  case 'human_ap'
    ap = mean(human_ap/L0);
    fprintf(['Except using human benchmark (avg) amplitude...\n']);
  case 'human_oop'
    sigma = humanKaAvg;
    fprintf(['Except using human benchmark (avg) angle std...\n']);
  case 'human_diff'
    D = D37/mean(CBF_human)/(L0m)^2;
    fprintf(['Except using human benchmark (avg) CBF at 37C diffusion...\n']);
  case 'human_not_h'
    ap = mean(human_ap)/L0;
    sigma = humanKaAvg;
    pRand = human_pr;
    lambda = mean(human_lam);
    D = Dhuman;
    fprintf(['Using human benchmark (avg) except height...\n']);
  case 'human_not_ap'
    h = mean(human_h)/L0;
    sigma = humanKaAvg;
    pRand = human_pr;
    lambda = mean(human_lam);
    D = Dhuman;
    fprintf(['Using human benchmark (avg) except amplitude...\n']);
  case 'human_not_oop'
    h = mean(human_h)/L0;
    ap = mean(human_ap)/L0;
    pRand = human_pr;
    lambda = mean(human_lam);
    D = Dhuman;
    fprintf(['Using human benchmark (avg) except angle std...\n']);
  case 'human_not_diff'
    h = mean(human_h)/L0;
    ap = mean(human_ap)/L0;
    sigma = humanKaAvg;
    pRand = human_pr;
    lambda = mean(human_lam);
    fprintf(['Using human benchmark (avg) except CBF at 37C diffusion...\n']);
  case ''
  otherwise
    error('invalid modifier option!!!');
end

-->
