<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Filament Trace Web App</title>
  <style>
    :root {
      --bg: #080b12;
      --fg: #e5e7eb;
      --muted: #94a3b8;
      --acc: #60a5fa;
      --panel: #0f172a;
      --border: #1f2937;
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font: 14px/1.5 "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    kbd {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.75);
      font-family: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      color: var(--fg);
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .app {
      display: grid;
      grid-template-columns: minmax(260px, 340px) 1fr;
      grid-template-rows: auto 1fr;
      min-height: 100vh;
      background: radial-gradient(circle at top left, rgba(96,165,250,.08), transparent 40%),
                  radial-gradient(circle at bottom right, rgba(244,114,182,.06), transparent 45%),
                  var(--bg);
    }
    header {
      grid-column: 1 / -1;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: rgba(8,11,18,0.75);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 2;
    }
    header .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    header h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .quick-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-left: auto;
    }
    .panel {
      background: rgba(15,23,42,0.92);
      border-right: 1px solid var(--border);
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
    }
    .group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .group h2 {
      margin: 0;
      font-size: 12px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .grid-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 10px;
    }
    .flow-buttons {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    .btn {
      background: #111c32;
      border: 1px solid rgba(148,163,184,0.2);
      color: var(--fg);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font: inherit;
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .btn:hover {
      border-color: rgba(96,165,250,0.6);
      background: rgba(17,24,39,0.95);
      transform: translateY(-1px);
    }
    .btn.secondary {
      background: rgba(15,23,42,0.9);
    }
    .workspace {
      position: relative;
      display: flex;
      flex-direction: column;
      padding: 20px;
      gap: 16px;
      overflow-y: auto;
      overflow-x: hidden;
    }
    #container {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 18px;
      padding: 32px 28px 36px;
      border-radius: 16px;
      border: 1px dashed rgba(96,165,250,0.35);
      background: rgba(15,23,42,0.52);
      transition: border-color 0.25s ease, box-shadow 0.25s ease;
      min-height: 420px;
      backdrop-filter: blur(6px);
    }
    #container.drag-over {
      border-color: rgba(96,165,250,0.85);
      box-shadow: 0 0 0 2px rgba(96,165,250,0.25), 0 24px 55px rgba(15,23,42,0.6);
    }
    #dropText {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 18px;
      color: rgba(148,163,184,0.7);
      letter-spacing: 0.04em;
      pointer-events: none;
    }
    canvas {
      width: 100%;
      background: #020617;
      border-radius: 12px;
      border: 1px solid rgba(15,23,42,0.9);
      box-shadow: 0 14px 30px rgba(2,6,23,0.45);
      display: block;
    }
    canvas:focus {
      outline: 2px solid var(--acc);
      outline-offset: 4px;
    }
    #canvas2 {
      background: #0b1220;
    }
    /* removed dedicated scale bar canvas */
    #imgIndicator {
      font-size: 13px;
      letter-spacing: 0.06em;
      color: var(--muted);
      text-transform: uppercase;
    }
    #playPauseContainer {
      display: flex;
      justify-content: center;
    }
    #btnPlayPause {
      min-width: 160px;
      background: linear-gradient(135deg, rgba(96,165,250,0.28), rgba(14,165,233,0.22));
      border: 1px solid rgba(14,165,233,0.35);
    }
    #btnPlayPause:hover {
      background: linear-gradient(135deg, rgba(96,165,250,0.42), rgba(14,165,233,0.35));
    }
    #fileInput,
    #reloadFileInput {
      display: none;
    }
    .status-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      font-size: 12px;
      color: rgba(148,163,184,0.85);
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.16);
      background: rgba(15,23,42,0.72);
    }
    .status-bar span {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .status-bar strong {
      color: var(--fg);
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 11px;
    }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(2,6,23,0.65);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 30;
    }
    .modal-backdrop.open {
      display: flex;
    }
    .modal {
      width: min(540px, 90vw);
      max-height: 80vh;
      overflow-y: auto;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(96,165,250,0.35);
      border-radius: 18px;
      box-shadow: 0 28px 80px rgba(2,6,23,0.65);
      padding: 24px 28px 28px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .modal header {
      padding: 0;
      border: none;
      background: transparent;
      position: static;
    }
    .modal header h2 {
      margin: 0;
      font-size: 18px;
      color: var(--fg);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .modal header button {
      margin-left: auto;
      background: transparent;
      border: 1px solid rgba(148,163,184,0.35);
      color: var(--muted);
      border-radius: 999px;
      width: 32px;
      height: 32px;
      cursor: pointer;
    }
    .modal header button:hover {
      color: var(--fg);
      border-color: rgba(96,165,250,0.6);
    }
    .modal ol {
      margin: 0;
      padding-left: 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      color: rgba(226,232,240,0.92);
      font-size: 14px;
    }
    .modal ol li strong {
      color: var(--acc);
      font-weight: 600;
    }
    .modal footer {
      display: flex;
      justify-content: flex-end;
    }
    .modal footer button {
      background: var(--acc);
      border: none;
      color: #0b1120;
      padding: 10px 18px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .modal footer button:hover {
      filter: brightness(1.1);
    }
    @media (max-width: 960px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr;
      }
      .panel {
        grid-row: 2;
        border-right: none;
        border-bottom: 1px solid var(--border);
        flex-direction: row;
        flex-wrap: wrap;
        gap: 18px;
      }
      .panel .group {
        flex: 1 1 220px;
      }
      .workspace {
        grid-row: 3;
      }
    }
    @media (max-width: 640px) {
      header .row {
        flex-direction: column;
        align-items: flex-start;
      }
      .quick-actions {
        width: 100%;
        justify-content: flex-start;
      }
      #canvas {
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="row">
        <h1>Filament Tracer Utility</h1>
        <div class="quick-actions">
          <button id="btnLoad" class="btn">Load (L)</button>
          <button id="btnExport" class="btn">Export (E)</button>
          <button id="btnHelp" class="btn secondary">Help</button>
        </div>
      </div>
    </header>
    <aside class="panel">
      <div class="group">
        <h2>Tracing</h2>
        <div class="grid-buttons">
          <button id="btnNext" class="btn secondary">New Filament (N)</button>
          <button id="btnReset" class="btn secondary">Reset Current (R)</button>
          <button id="btnUndo" class="btn secondary">Undo Point (U)</button>
          <button id="btnSmooth" class="btn secondary">Smoothen All (S)</button>
        </div>
      </div>
      <div class="group">
        <h2>Calibration and Navigation</h2>
        <div class="grid-buttons">
          <button id="btnCalib" class="btn secondary">Calibrate Scalebar (C)</button>
          <button id="btnReload" class="btn secondary">Add Traced Results (A)</button>
        </div>
        <div class="flow-buttons">
          <button id="btnPrev" class="btn secondary">Previous Frame (J)</button>
          <button id="btnNextImg" class="btn secondary">Next Frame (K)</button>
        </div>
      </div>
    </aside>
    <main class="workspace">
      <div id="container">
        <div id="dropText">Drop microscopy frames or click Load (L)</div>
        <canvas id="canvas" tabindex="0"></canvas>
        <canvas id="canvas2" height="200"></canvas>
        <div id="imgIndicator"></div>
      </div>
      <div id="playPauseContainer">
        <button id="btnPlayPause" class="btn">Animate</button>
      </div>
      <div class="status-bar">
        <span><strong>Tracing</strong> click to place points, press N to store a filament.</span>
        <span><strong>Keyboard</strong> L / N / R / U / C / S / E / A / J / K</span>
      </div>
    </main>
  </div>
  <div class="modal-backdrop" id="helpModal">
    <div class="modal">
      <header>
        <h2>Filament tracing guide</h2>
        <button type="button" data-close-help>&times;</button>
      </header>
      <ol>
        <li><strong>Load frames:</strong> Press <kbd>L</kbd> or click <em>Load</em>, drag multiple files to annotate sequences.</li>
        <li><strong>Trace filaments:</strong> Left-click to add points. Use <strong>N</strong> to commit a filament and advance.</li>
        <li><strong>Undo / Reset:</strong> <strong>U</strong> removes the last point, <strong>R</strong> clears the current trace.</li>
        <li><strong>Calibrate scale:</strong> Press <strong>C</strong>, click two reference points, then enter the distance in μm.</li>
        <li><strong>Smooth traces:</strong> <strong>S</strong> applies Savitzky–Golay smoothing while locking endpoints.</li>
        <li><strong>Animate paths:</strong> Use the animate button to review saved filaments in sequence.</li>
        <li><strong>Export / Import:</strong> <strong>E</strong> saves CSV data, <strong>A</strong> merges previous traces from CSV.</li>
        <li><strong>Navigate frames:</strong> <strong>J</strong> / <strong>K</strong> (or buttons) move between images in a sequence.</li>
      </ol>
      <footer>
        <button type="button" data-close-help>Start tracing</button>
      </footer>
    </div>
  </div>
  <input type="file" id="reloadFileInput" accept=".csv">
  <input type="file" id="fileInput" accept="image/*" multiple>
  
  <script>
    // Global variables (JS numbers are double precision)
    const container = document.getElementById('container');
    const dropText = document.getElementById('dropText');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const canvas2 = document.getElementById('canvas2');
    const ctx2 = canvas2.getContext('2d');
    // dedicated scale bar canvas removed
    const imgIndicator = document.getElementById('imgIndicator');
    const helpModal = document.getElementById('helpModal');
    const helpCloseButtons = document.querySelectorAll('[data-close-help]');
    const btnHelp = document.getElementById('btnHelp');

    function focusCanvas() {
      if (!canvas || helpModal.classList.contains('open')) return;
      requestAnimationFrame(() => {
        canvas.focus({ preventScroll: true });
      });
    }

    document.querySelectorAll('.btn').forEach(button => {
      if (button === btnHelp) return;
      button.addEventListener('click', () => {
        requestAnimationFrame(() => {
          button.blur();
          focusCanvas();
        });
      });
    });
    // Filament points stored as normalized [x,y]
    let currentFilament = [];
    let filamentCoords = [];
    // For main canvas display: stored filaments with fading
    let storedFilaments = [];
    let arclengths = [];
    let tangentAngles = [];
    let px2um = 0.01;
    let fps = 1; // default FPS
    let images = [];
    let currentImageIndex = 0;
    let currentImage = new Image();
    let calibrationActive = false;
    
    // Animation globals for play/pause    
    const btnPlayPause = document.getElementById('btnPlayPause');
    let isPlaying = false;
    let animInterval = null;
    let animIndex = 0; // which saved filament is highlighted

    function openHelp() {
      helpModal.classList.add('open');
      document.body.style.overflow = 'hidden';
      if (btnHelp) {
        btnHelp.blur();
      }
    }

    function closeHelp() {
      helpModal.classList.remove('open');
      document.body.style.overflow = '';
      focusCanvas();
    }

    if (btnHelp) {
      btnHelp.addEventListener('click', openHelp);
    }
    helpCloseButtons.forEach(btn => btn.addEventListener('click', closeHelp));
    helpModal.addEventListener('click', (e) => {
      if (e.target === helpModal) {
        closeHelp();
      }
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && helpModal.classList.contains('open')) {
        closeHelp();
      }
    });
    
    // When an image loads, hide drop text and update indicator.
    currentImage.onload = function() {
      dropText.style.display = 'none';
      resizeCanvas();
      draw();
      drawSaved();
      updateIndicator();
      focusCanvas();
    };
    
    const btnReload = document.getElementById('btnReload');
    const reloadFileInput = document.getElementById('reloadFileInput');
    
    btnReload.addEventListener('click', () => reloadFileInput.click());

    // Resize main canvas responsively while keeping draw and CSS sizes in sync.
    function resizeCanvas() {
      if (!currentImage.width) return;
      const styles = getComputedStyle(container);
      const horizontalPadding = parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
      const availableWidth = Math.max(320, container.clientWidth - horizontalPadding);
      const maxHeight = Math.max(240, window.innerHeight * 0.65);
      let scaledWidth = availableWidth;
      let scaledHeight = currentImage.height * (scaledWidth / currentImage.width);
      if (scaledHeight > maxHeight) {
        scaledHeight = maxHeight;
        scaledWidth = currentImage.width * (scaledHeight / currentImage.height);
      }
      canvas.width = scaledWidth;
      canvas.height = scaledHeight;
      canvas.style.width = `${scaledWidth}px`;
      canvas.style.height = `${scaledHeight}px`;

      canvas2.width = scaledWidth;
      canvas2.style.width = `${scaledWidth}px`;
      canvas2.style.height = `${canvas2.height}px`;
    }
    
    window.addEventListener('resize', () => {
      if (currentImage.complete) {
        resizeCanvas();
        draw();
        drawSaved();
      }
    });
    
    // Update image indicator
    function updateIndicator() {
      if (images.length > 0) {
        imgIndicator.innerText = `Showing image ${currentImageIndex + 1} out of ${images.length}`;
      } else {
        imgIndicator.innerText = "";
      }
    }
    
    // Try to load a default example image if available
    function tryLoadDefaultImage() {
      if (images.length > 0 || (currentImage && currentImage.width)) return;
      const path = 'images/example.png';
      const img = new Image();
      img.onload = function() {
        // Only apply if the user hasn't loaded anything yet
        if (images.length === 0) {
          images = [img];
          currentImageIndex = 0;
          currentImage = img;
          dropText.style.display = 'none';
          resizeCanvas();
          draw();
          drawSaved();
          updateIndicator();
          focusCanvas();
        }
      };
      img.onerror = function() { /* ignore if missing */ };
      img.src = path;
    }
    
    // Show user guide on load.
    window.addEventListener('load', function() {
      openHelp();
      tryLoadDefaultImage();
      if (currentImage.complete && currentImage.width) {
        resizeCanvas();
        draw();
        drawSaved();
        updateIndicator();
      }
    });
    
    reloadFileInput.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        reloadFilamentsFromCSV(file);
      } else {
        focusCanvas();
      }
    });
    
    // --- Drag & Drop and File Loading ---
    container.addEventListener('dragover', function(e) {
      e.preventDefault();
      container.classList.add('drag-over');
    });
    container.addEventListener('dragleave', function(e) {
      e.preventDefault();
      if (e.target === container) {
        container.classList.remove('drag-over');
      }
    });
    container.addEventListener('drop', function(e) {
      e.preventDefault();
      container.classList.remove('drag-over');
      const dt = e.dataTransfer;
      const files = Array.from(dt.files).filter(file => file.type.startsWith("image/"));
      if (files.length > 0) {
        loadFiles(files);
      } else {
        focusCanvas();
      }
    });
    
    const btnLoad = document.getElementById('btnLoad');
    const fileInput = document.getElementById('fileInput');
    btnLoad.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', function(e) {
      const files = Array.from(e.target.files);
      if (!files.length) {
        focusCanvas();
        return;
      }
      loadFiles(files);
    });
    
    function loadFiles(files) {
      files.sort((a, b) => a.name.localeCompare(b.name));
      images = [];
      const loadPromises = [];
      for (let file of files) {
        const img = new Image();
        let promise = new Promise(resolve => { img.onload = () => resolve(img); });
        img.src = URL.createObjectURL(file);
        loadPromises.push(promise);
        images.push(img);
      }
      Promise.all(loadPromises).then(loadedImages => {
        currentImageIndex = 0;
        currentImage = loadedImages[0];
        dropText.style.display = 'none';
        if (loadedImages.length > 1) {
          const input = prompt("Image sequence detected (multiple image files selected), please specify frame-per-second (FPS):", "1");
          fps = parseFloat(input) || 1;
        } else {
          fps = 1;
        }
        resizeCanvas();
        draw();
        drawSaved();
        updateIndicator();
        focusCanvas();
      });
    }
    function reloadFilamentsFromCSV(file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const text = e.target.result;
        const lines = text.split(/\r?\n/).map(line => line.trim()).filter(line => line.length > 0);
        // Look for the "Normalized Coordinates:" header
        const normIdx = lines.findIndex(line => line === "Normalized Coordinates:");
        let newFilamentCoords = [];
        if (normIdx !== -1) {
          // Parse normalized coordinates: each line after the header until an empty line
          for (let i = normIdx + 1; i < lines.length; i++) {
            if (lines[i] === "") break;
            // Each line: "x1,y1;x2,y2;...;xn,yn"
            const pairs = lines[i].split(";");
            const filament = pairs.map(pair => {
              const [x, y] = pair.split(",");
              return [parseFloat(x), parseFloat(y)];
            });
            newFilamentCoords.push(filament);
          }
        } else {
          // No "Normalized Coordinates:" section found; try to load X and Y sections.
          const xIdx = lines.findIndex(line => line.startsWith("X-coordinates"));
          const yIdx = lines.findIndex(line => line.startsWith("Y-coordinates"));
          if (xIdx !== -1 && yIdx !== -1) {
            alert("No normalized coordinates found use X/Y instead.");
            let xCoords = [];
            let i = xIdx + 1;
            while (i < lines.length && lines[i].includes(",")) {
              // Each line is comma-separated numbers.
              xCoords.push(lines[i].split(",").map(Number));
              i++;
            }
            let yCoords = [];
            i = yIdx + 1;
            while (i < lines.length && lines[i].includes(",")) {
              yCoords.push(lines[i].split(",").map(Number));
              i++;
            }
            // Assume each row corresponds to one filament.
            for (let j = 0; j < Math.min(xCoords.length, yCoords.length); j++) {
              let filament = [];
              for (let k = 0; k < Math.min(xCoords[j].length, yCoords[j].length); k++) {
                filament.push([xCoords[j][k], yCoords[j][k]]);
              }
              // Shift the filament so its first point is [0,0]
              if (!isNaN(filament[0][0])) {
                let shiftX = filament[0][0], shiftY = filament[0][1];
                filament = filament.map(p => [p[0] - shiftX, p[1] - shiftY]);
              }
              newFilamentCoords.push(filament);
            }
          } else {
            alert("No normalized coordinates or X/Y sections found in CSV.");
            return;
          }
        }
        filamentCoords = newFilamentCoords;
        // Update stored filaments (all at full opacity)
        storedFilaments = filamentCoords.map(fil => ({ points: fil, opacity: 1 }));
        drawSaved();
        focusCanvas();
      };
      reader.readAsText(file);
    }
    
    // --- Filament Functions ---
    const btnNext = document.getElementById('btnNext');
    btnNext.addEventListener('click', nextFilament);
    function nextFilament() {
      if (currentFilament.length === 0) return;
      filamentCoords.push([...currentFilament]);
      let length = 0, angles = [];
      for (let i = 1; i < currentFilament.length; i++) {
        const x1 = currentFilament[i-1][0] * canvas.width;
        const y1 = currentFilament[i-1][1] * canvas.height;
        const x2 = currentFilament[i][0] * canvas.width;
        const y2 = currentFilament[i][1] * canvas.height;
        const dx = x2 - x1, dy = y2 - y1;
        length += Math.hypot(dx, dy);
        angles.push(Math.atan2(dy, dx));
      }
      arclengths.push(length);
      tangentAngles.push(angles);
      storedFilaments.forEach(f => f.opacity *= 0.2 );
      storedFilaments.push({ points: [...currentFilament], opacity: 0.5 });
      currentFilament = [];
      if (images.length > 1) {
        currentImageIndex = (currentImageIndex + 1) % images.length;
        currentImage = images[currentImageIndex];
        if (currentImage.complete) {
          resizeCanvas();
          draw();
          drawSaved();
          updateIndicator();
        } else {
          currentImage.onload = function() {
            resizeCanvas();
            draw();
            drawSaved();
            updateIndicator();
            focusCanvas();
          };
        }
      }
      draw();
      drawSaved();
      updateIndicator();
      focusCanvas();
    }
    
    const btnReset = document.getElementById('btnReset');
    btnReset.addEventListener('click', () => {
      currentFilament = [];
      draw();
      focusCanvas();
    });
    
    const btnUndo = document.getElementById('btnUndo');
    btnUndo.addEventListener('click', undoPoint);
    function undoPoint() {
      if (currentFilament.length > 0) {
        currentFilament.pop();
      } else if (filamentCoords.length > 0) {
        currentFilament = filamentCoords.pop();
        if (storedFilaments.length > 0) storedFilaments.pop();
      } else {
        console.log("Nothing to undo.");
      }
      draw();
      drawSaved();
      focusCanvas();
    }

    const btnCalib = document.getElementById('btnCalib');
    btnCalib.addEventListener('click', calibrate);
    function calibrate() {
      alert("Click two points on the image to set scale bar information.");
      calibrationActive = true;
      let calibPoints = [];
      focusCanvas();
      function calibClick(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        calibPoints.push([x, y]);
        if (calibPoints.length === 2) {
          canvas.removeEventListener('click', calibClick);
          calibrationActive = false;
          const dx = calibPoints[1][0] - calibPoints[0][0];
          const dy = calibPoints[1][1] - calibPoints[0][1];
          const pixelDist = Math.hypot(dx, dy);
          let realDist = prompt("Enter the physical length (um):");
          realDist = parseFloat(realDist);
          if (realDist > 0) {
            px2um = realDist / pixelDist;
            draw();
            drawSaved();
          } else {
            alert("Invalid input.");
          }
          focusCanvas();
        }
        drawSaved();
      }
      canvas.addEventListener('click', calibClick);
    }
    
    // --- Smoothing using Savitzky–Golay filter (5-point window, endpoints fixed) ---
    function sgolaySmooth(arr) {
      if (arr.length < 5) return arr.slice();
      let smoothed = arr.slice();
      for (let i = 2; i < arr.length - 2; i++) {
        smoothed[i] = (-3 * arr[i-2] + 12 * arr[i-1] + 17 * arr[i] + 12 * arr[i+1] - 3 * arr[i+2]) / 35;
      }
      return smoothed;
    }
    const btnSmooth = document.getElementById('btnSmooth');
    btnSmooth.addEventListener('click', smoothFilaments);
    function smoothFilaments() {
      for (let i = 0; i < filamentCoords.length; i++) {
        let pts = filamentCoords[i];
        let xs = pts.map(p => p[0]);
        let ys = pts.map(p => p[1]);
        let smoothX = sgolaySmooth(xs);
        let smoothY = sgolaySmooth(ys);
        // Fix endpoints.
        smoothX[0] = xs[0];
        smoothX[smoothX.length - 1] = xs[xs.length - 1];
        smoothY[0] = ys[0];
        smoothY[smoothY.length - 1] = ys[ys.length - 1];
        let newPts = smoothX.map((x, j) => [x, smoothY[j]]);
        filamentCoords[i] = newPts;
      }
      for (let i = 0; i < storedFilaments.length; i++) {
        storedFilaments[i].points = filamentCoords[i];
      }
      draw();
      drawSaved();
      focusCanvas();
    }
    
    // --- Reparameterize each filament to 20 points, shift so first point is [0,0], compute velocities.
    function reparameterizeFilament(fil, numPoints) {
    if (fil.length < 2)
            return { points: [], velocities: [] };
    
        // Convert normalized points to pixel coordinates.
        let pts = fil.map(p => [ p[0] * canvas.width, p[1] * canvas.height ]);
        let cumDist = [0];
        for (let i = 1; i < pts.length; i++) {
            let dx = pts[i][0] - pts[i-1][0];
            let dy = pts[i][1] - pts[i-1][1];
            cumDist.push(cumDist[i-1] + Math.hypot(dx, dy));
        }
        let totalLength = cumDist[cumDist.length - 1];
        let newPts = [];
        for (let j = 0; j < numPoints; j++) {
            let d = totalLength * j / (numPoints - 1);
            let i = 0;
            while (i < cumDist.length - 1 && cumDist[i+1] < d) {
                i++;
            }
            // If d is at or beyond the last segment, force the last segment.
            if (i >= cumDist.length - 1) {
                i = cumDist.length - 2;
                t = 1;
            } else {
                let segmentLength = cumDist[i+1] - cumDist[i];
                var t = segmentLength === 0 ? 0 : (d - cumDist[i]) / segmentLength;
            }
            let x = pts[i][0] + t * (pts[i+1][0] - pts[i][0]);
            let y = pts[i][1] + t * (pts[i+1][1] - pts[i][1]);
            newPts.push([x, y]);
        }
        // Shift so that the first point is [0,0]
        let shiftX = newPts[0][0], shiftY = newPts[0][1];
        newPts = newPts.map(p => [ p[0] - shiftX, p[1] - shiftY ]);
        // Convert to physical units (um)
        newPts = newPts.map(p => [ p[0] * px2um, p[1] * px2um ]);
        // Compute velocities (um/s)
        let velocities = [];
        for (let j = 1; j < newPts.length; j++) {
            let dx = newPts[j][0] - newPts[j-1][0];
            let dy = newPts[j][1] - newPts[j-1][1];
            velocities.push(Math.hypot(dx, dy) * fps);
        }
        return { points: newPts, velocities: velocities };
    }
    
    // --- CSV Export ---
    const btnExport = document.getElementById('btnExport');
    btnExport.addEventListener('click', exportData);
    function exportData() {
      let csvContent = "";
      csvContent += `px2um,${px2um}\n`;
      csvContent += `nFrames,${images.length > 0 ? images.length : 1}\n`;
      csvContent += `fps,${fps}\n\n`;
      let reparamData = filamentCoords.map(fil => reparameterizeFilament(fil, 20));
      csvContent += "X-coordinates (um):\n";
      reparamData.forEach(data => {
        let xs = data.points.map(p => p[0].toFixed(12));
        csvContent += xs.join(",") + "\n";
      });
      csvContent += "\nY-coordinates (um):\n";
      reparamData.forEach(data => {
        let ys = data.points.map(p => p[1].toFixed(12));
        csvContent += ys.join(",") + "\n";
      });
      csvContent += "\nTangent Angles (rad):\n";
      reparamData.forEach(data => {
        let pts = data.points;
        let angs = [];
        for (let j = 1; j < pts.length; j++) {
          let dx = pts[j][0] - pts[j-1][0];
          let dy = pts[j][1] - pts[j-1][1];
          angs.push(Math.atan2(dy, dx).toFixed(12));
        }
        csvContent += angs.join(",") + "\n";
      });
      csvContent += "\nArc Lengths (um):\n";
      reparamData.forEach(data => {
        let pts = data.points;
        let total = 0;
        for (let j = 1; j < pts.length; j++) {
          let dx = pts[j][0] - pts[j-1][0];
          let dy = pts[j][1] - pts[j-1][1];
          total += Math.hypot(dx, dy);
        }
        csvContent += total.toFixed(12) + "\n";
      });
      csvContent += "\nVelocities (um/s):\n";
      reparamData.forEach(data => {
        csvContent += data.velocities.map(v => v.toFixed(12)).join(",") + "\n";
      });
      
      // Append the original normalized coordinates.
      csvContent += "\nNormalized Coordinates:\n";
      filamentCoords.forEach(fil => {
        // Each filament is written as a semicolon-separated list of "x,y" pairs.
        let normCoords = fil.map(p => p[0].toFixed(12) + "," + p[1].toFixed(12)).join(";");
        csvContent += normCoords + "\n";
      });
      
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const now = new Date();
      const dateStr = now.toISOString().slice(0,10);
      a.download = `filament_trace_${dateStr}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    // --- Image Navigation using keys J and K and on-screen buttons ---
    const btnPrev = document.getElementById('btnPrev');
    const btnNextImg = document.getElementById('btnNextImg');
    btnPrev.addEventListener('click', prevImage);
    btnNextImg.addEventListener('click', nextImage);
    function prevImage() {
      if (images.length > 1) {
        currentImageIndex = (currentImageIndex - 1 + images.length) % images.length;
        currentImage = images[currentImageIndex];
        if (currentImage.complete) {
          resizeCanvas();
          draw();
          drawSaved();
          updateIndicator();
        } else {
          currentImage.onload = function() {
            resizeCanvas();
            draw();
            drawSaved();
            updateIndicator();
            focusCanvas();
          };
        }
        focusCanvas();
      }
    }
    function nextImage() {
      if (images.length > 1) {
        currentImageIndex = (currentImageIndex + 1) % images.length;
        currentImage = images[currentImageIndex];
        if (currentImage.complete) {
          resizeCanvas();
          draw();
          drawSaved();
          updateIndicator();
        } else {
          currentImage.onload = function() {
            resizeCanvas();
            draw();
            drawSaved();
            updateIndicator();
            focusCanvas();
          };
        }
        focusCanvas();
      }
    }
    
    // --- Canvas click for drawing points ---
    canvas.addEventListener('click', function(e) {
      if (calibrationActive) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      currentFilament.push([x / canvas.width, y / canvas.height]);
      draw();
      focusCanvas();
    });
    
    // --- Key Bindings ---
    window.addEventListener('keydown', function(e) {
      if (helpModal.classList.contains('open')) return;
      const targetTag = e.target && e.target.tagName ? e.target.tagName.toLowerCase() : '';
      if (targetTag === 'input' || targetTag === 'textarea' || (e.target && e.target.isContentEditable)) {
        return;
      }
      switch(e.key.toLowerCase()){
        case 'l': e.preventDefault(); btnLoad.click(); break;
        case 'n': e.preventDefault(); nextFilament(); break;
        case 'r':
          e.preventDefault();
          currentFilament = [];
          draw();
          focusCanvas();
          break;
        case 'u': e.preventDefault(); undoPoint(); break;
        case 'c': e.preventDefault(); calibrate(); break;
        case 's': e.preventDefault(); smoothFilaments(); break;
        case 'e':
          e.preventDefault();
          exportData();
          focusCanvas();
          break;
        case 'j': e.preventDefault(); prevImage(); break;
        case 'k': e.preventDefault(); nextImage(); break;
        case 'a': e.preventDefault(); btnReload.click(); break;
      }
    });
    
    // --- Drawing Functions ---
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (currentImage.complete) {
        ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
      }
      // Draw stored filaments on main canvas with onion-skin fading.
      storedFilaments.forEach(fil => {
        ctx.strokeStyle = `rgba(255,0,0,${fil.opacity})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        fil.points.forEach((pt, i) => {
          let x = pt[0] * canvas.width;
          let y = pt[1] * canvas.height;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
        fil.points.forEach(pt => {
          ctx.fillStyle = `rgba(255,0,0,${fil.opacity})`;
          ctx.beginPath();
          ctx.arc(pt[0] * canvas.width, pt[1] * canvas.height, 3, 0, 2 * Math.PI);
          ctx.fill();
        });
      });
      // Draw current filament in full red.
      if (currentFilament.length > 0) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.beginPath();
        currentFilament.forEach((pt, i) => {
          let x = pt[0] * canvas.width;
          let y = pt[1] * canvas.height;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
        currentFilament.forEach(pt => {
          ctx.fillStyle = 'red';
          ctx.beginPath();
          ctx.arc(pt[0] * canvas.width, pt[1] * canvas.height, 3, 0, 2 * Math.PI);
          ctx.fill();
        });
      }
      // Draw calibrated scale bar overlay in the main viewport
      drawScaleBarOnMain();
    }

    // Draw the scale bar directly on the main tracing canvas (same viewport)
    function drawScaleBarOnMain() {
      if (!canvas.width || !canvas.height) return;
      const desiredUm = 10; // physical length to display
      const margin = 18; // px margin from edges
      const startX = margin;
      const startY = canvas.height - margin;
      // Convert desired μm to pixels using calibration (μm per px)
      let barPx = desiredUm / px2um;
      // Clamp to available width
      const maxBarPx = Math.max(20, canvas.width - startX * 2);
      barPx = Math.min(barPx, maxBarPx);
      ctx.save();
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(startX + barPx, startY);
      ctx.stroke();
      ctx.fillStyle = 'white';
      ctx.font = '16px Arial';
      ctx.textBaseline = 'bottom';
      ctx.fillText('10 μm', startX, startY - 8);
      ctx.restore();
    }
    
    // --- Play/Pause Animation for Saved Filaments in Canvas2 ---
    btnPlayPause.addEventListener('click', function() {
      if (isPlaying) {
        clearInterval(animInterval);
        btnPlayPause.innerText = "Animate";
      } else {
        animIndex = 0;
        animInterval = setInterval(function() {
          // Cycle through saved filaments: redraw canvas2 with current animIndex filament in black.
          drawSavedAnimated(animIndex);
          animIndex = (animIndex + 1) % filamentCoords.length;
        }, 300);
        btnPlayPause.innerText = "Pause";
      }
      isPlaying = !isPlaying;
    });
    
    // Modified drawSaved function for animation.
    function drawSavedAnimated(highlightIndex) {
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        if (filamentCoords.length === 0) return;
        
        // 1. Shift each filament so its first point becomes [0,0]
        let shiftedFilaments = filamentCoords.map(fil => {
            return fil.map(p => [ p[0] - fil[0][0], p[1] - fil[0][1] ]);
        });
        
        // 2. Convert shifted normalized coordinates to canvas2 pixels.
        let allPts = [];
        shiftedFilaments.forEach(fil => {
            fil.forEach(p => {
                allPts.push([ p[0] * canvas2.width, p[1] * canvas2.height ]);
            });
        });
        if(allPts.length === 0) return;
        
        // 3. Compute the bounding box of all shifted points.
        let minX = Math.min(...allPts.map(p => p[0]));
        let maxX = Math.max(...allPts.map(p => p[0]));
        let minY = Math.min(...allPts.map(p => p[1]));
        let maxY = Math.max(...allPts.map(p => p[1]));
        let bboxWidth = maxX - minX;
        let bboxHeight = maxY - minY;
        
        // 4. Compute a uniform scale factor to fit the bounding box into canvas2.
        let scaleFactor = Math.min(
          bboxWidth === 0 ? Infinity : canvas2.width / bboxWidth,
          bboxHeight === 0 ? Infinity : canvas2.height / bboxHeight
        );
        if (!Number.isFinite(scaleFactor) || scaleFactor === 0) {
          scaleFactor = 1;
        }
        
        // 5. Compute offsets to center the bounding box in canvas2.
        let offsetX = (canvas2.width - bboxWidth * scaleFactor) / 2 - (minX * scaleFactor);
        let offsetY = (canvas2.height - bboxHeight * scaleFactor) / 2 - (minY * scaleFactor);
        
        // 6. Draw each shifted filament with the computed transform.
        shiftedFilaments.forEach((fil, idx) => {
            // Convert each normalized point to canvas2 pixel space.
            let pts = fil.map(p => [ p[0] * canvas2.width, p[1] * canvas2.height ]);
            // Apply scale and offset.
            pts = pts.map(p => [ p[0] * scaleFactor + offsetX, p[1] * scaleFactor + offsetY ]);
            ctx2.strokeStyle = (idx === highlightIndex) ? 'white' : 'red';
            ctx2.lineWidth = 2;
            ctx2.beginPath();
            pts.forEach((pt, i) => {
                if (i === 0) ctx2.moveTo(pt[0], pt[1]);
                else ctx2.lineTo(pt[0], pt[1]);
            });
            ctx2.stroke();
        });

        // Draw calibrated scale bar in canvas2 (10 μm)
        if (canvas.width) {
          const desiredUm = 10;
          let barPxMain = desiredUm / px2um; // pixels on main canvas
          let barPxCanvas2 = (barPxMain / canvas.width) * canvas2.width * scaleFactor;
          const margin = 18;
          const maxBar = Math.max(20, canvas2.width - margin * 2);
          barPxCanvas2 = Math.min(barPxCanvas2, maxBar);
          const startX = margin;
          const startY = canvas2.height - margin;
          ctx2.save();
          ctx2.strokeStyle = 'white';
          ctx2.lineWidth = 4;
          ctx2.beginPath();
          ctx2.moveTo(startX, startY);
          ctx2.lineTo(startX + barPxCanvas2, startY);
          ctx2.stroke();
          ctx2.fillStyle = 'white';
          ctx2.font = '16px Arial';
          ctx2.textBaseline = 'bottom';
          ctx2.fillText('10 μm', startX, startY - 8);
          ctx2.restore();
        }
    }
    
    function drawSaved() {
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        if (filamentCoords.length === 0) return;
        
        // 1. Shift each filament so its first point is [0,0]
        let shiftedFilaments = filamentCoords.map(fil => {
            // Each filament: subtract the first point
            return fil.map(p => [p[0] - fil[0][0], p[1] - fil[0][1]]);
        });
        
        // 2. Convert shifted normalized coordinates to pixel coordinates for canvas2
        let allPts = [];
        shiftedFilaments.forEach(fil => {
            fil.forEach(p => {
                allPts.push([ p[0] * canvas2.width, p[1] * canvas2.height ]);
            });
        });
        if(allPts.length === 0) return;
        
        // 3. Compute bounding box of all shifted points
        let minX = Math.min(...allPts.map(p => p[0]));
        let maxX = Math.max(...allPts.map(p => p[0]));
        let minY = Math.min(...allPts.map(p => p[1]));
        let maxY = Math.max(...allPts.map(p => p[1]));
        let bboxWidth = maxX - minX;
        let bboxHeight = maxY - minY;
        
        // 4. Compute scale factor to fit the bounding box into canvas2
        let scaleFactor = Math.min(
          bboxWidth === 0 ? Infinity : canvas2.width / bboxWidth,
          bboxHeight === 0 ? Infinity : canvas2.height / bboxHeight
        );
        if (!Number.isFinite(scaleFactor) || scaleFactor === 0) {
          scaleFactor = 1;
        }
        
        // 5. Compute offsets to center the bounding box in canvas2
        let offsetX = (canvas2.width - bboxWidth * scaleFactor) / 2 - minX * scaleFactor;
        let offsetY = (canvas2.height - bboxHeight * scaleFactor) / 2 - minY * scaleFactor;
        
        // 6. For each shifted filament, apply the scale and offset, then draw.
        shiftedFilaments.forEach(fil => {
            // Convert normalized to pixel coordinates first.
            let pts = fil.map(p => [ p[0] * canvas2.width, p[1] * canvas2.height ]);
            // Then scale and translate.
            pts = pts.map(p => [ p[0] * scaleFactor + offsetX, p[1] * scaleFactor + offsetY ]);
            ctx2.strokeStyle = 'red';
            ctx2.lineWidth = 2;
            ctx2.beginPath();
            pts.forEach((pt, i) => {
                if (i === 0) ctx2.moveTo(pt[0], pt[1]);
                else ctx2.lineTo(pt[0], pt[1]);
            });
            ctx2.stroke();
        });

        // Draw calibrated scale bar in canvas2 (10 μm)
        if (canvas.width) {
          const desiredUm = 10;
          let barPxMain = desiredUm / px2um; // pixels on main canvas
          let barPxCanvas2 = (barPxMain / canvas.width) * canvas2.width * scaleFactor;
          const margin = 18;
          const maxBar = Math.max(20, canvas2.width - margin * 2);
          barPxCanvas2 = Math.min(barPxCanvas2, maxBar);
          const startX = margin;
          const startY = canvas2.height - margin;
          ctx2.save();
          ctx2.strokeStyle = 'white';
          ctx2.lineWidth = 4;
          ctx2.beginPath();
          ctx2.moveTo(startX, startY);
          ctx2.lineTo(startX + barPxCanvas2, startY);
          ctx2.stroke();
          ctx2.fillStyle = 'white';
          ctx2.font = '16px Arial';
          ctx2.textBaseline = 'bottom';
          ctx2.fillText('10 μm', startX, startY - 8);
          ctx2.restore();
        }
    }
    
    // removed dedicated scaleBarCanvas drawing function
  </script>
</body>
</html>
