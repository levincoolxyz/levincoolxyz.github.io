<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ciliary Carpet 3D Editor</title>
<style>
  :root{
    --bg:#0b0d12; --fg:#e8eaed; --muted:#9aa0a6; --panel:#0f131d; --border:#1f2937;
  }
  html,body{ height:100%; margin:0 }
  body{ background:var(--bg); color:var(--fg); font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif }
  .app{ display:grid; grid-template-columns:minmax(260px,360px) 1fr; grid-template-rows:auto 1fr; height:100% }
  header{ grid-column:1 / -1; padding:8px 12px; border-bottom:1px solid var(--border); background:#0f1113; color:#e5e7eb }
  header .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  header h1{ font-size:16px; margin:0 12px 0 0 }
  .btn{ background:#10192a; color:#e5e7eb; border:1px solid #2c3a4d; border-radius:8px; padding:8px 10px; cursor:pointer }
  .btn:hover{ background:#162236 }
  .btn-toggle{ width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px }
  .panel{ background:var(--panel); color:#e5e7eb; border-right:1px solid var(--border); padding:12px; overflow:auto }
  .app.collapsed{ grid-template-columns:0 1fr }
  .app.collapsed .panel{ padding:0; overflow:hidden; pointer-events:none; opacity:0 }
  .group{ margin:10px 0 14px }
  .group h3{ margin:0 0 8px 0; font-size:13px; color:#9aa0a6; letter-spacing:.06em; text-transform:uppercase }
  .row{ display:grid; grid-template-columns:1fr minmax(120px,160px); gap:8px; align-items:center; margin:6px 0 }
  .row label{ font-size:12px; color:#9aa0a6 }
  .row input[type=range], .row input[type=number], .row select{ width:100% }
  .row input[type=number], .row select{ background:#111827; color:#e5e7eb; border:1px solid #2f3847; border-radius:8px; padding:6px }
  .val{ margin-left:6px; color:#cbd5e1; font-variant-numeric:tabular-nums }
  main.canvas-wrap{ position:relative; display:flex; align-items:stretch; justify-content:stretch; background:#0b0b0b }
  #threeWrap{ position:relative; flex:1; min-height:clamp(320px, 70vh, 900px) }
  #threeWrap > canvas{ display:block; width:100%; height:100%; touch-action:none }
  #stats{ position:absolute; left:10px; bottom:10px; font:12px ui-monospace; color:#cbd5e1; background:rgba(0,0,0,.45); padding:6px 8px; border-radius:8px; white-space:pre }
  #err{ position:fixed; right:12px; bottom:12px; max-width:44ch; background:#2b1b1b; color:#ffdcdc; border:1px solid #a55; padding:8px 10px; border-radius:10px; font:12px ui-monospace; display:none; white-space:pre-wrap; z-index:100 }
  .hint{ font-size:12px; color:#9aa0a6 }
</style>
</head>
<body>
  <div class="app">
    <header>
      <div class="row">
        <button id="togglePanel" class="btn btn-toggle" title="Toggle controls" aria-expanded="true">«</button>
        <h1>Ciliary Carpet 3D Editor</h1>
        <button id="playPause" class="btn" title="Pause/Resume animation only">Pause</button>
        <button id="modeFate" class="btn" aria-pressed="false" title="Paint ciliation (Shift/right-click to erase)">edit: cell fate</button>
        <button id="modeBeatDir" class="btn" aria-pressed="false" title="Paint beat direction by dragging">edit: beat direction</button>
      </div>
    </header>

    <aside class="panel" aria-label="Controls">
      <div class="group">
        <h3>Grid</h3>
        <div class="row"><label>Cells X <span class="val" id="nXVal"></span></label><input id="nX" type="range" min="6" max="60" step="1" value="24"></div>
        <div class="row"><label>Cells Y <span class="val" id="nYVal"></span></label><input id="nY" type="range" min="6" max="60" step="1" value="20"></div>
        <div class="row"><label>Density (1/dX) <span class="val" id="densityVal"></span></label><input id="density" type="range" min="0.3" max="5" step="0.05" value="2.0"></div>
        <div class="row"><label>Jitter (crystalline) <span class="val" id="crystallineVal"></span></label><input id="crystalline" type="range" min="0" max="2" step="0.01" value="0.8"></div>
        <div class="row"><label>Coverage <span class="val" id="coverageVal"></span></label><input id="coverage" type="range" min="0" max="1" step="0.01" value="0.6"></div>
        <div class="row"><label>Patch size/domain <span class="val" id="patchlengthVal"></span></label><input id="patchlength" type="range" min="0.05" max="1.0" step="0.01" value="0.5"></div>
        <div class="row"><label>Patch order <span class="val" id="patchorderVal"></span></label><input id="patchorder" type="range" min="0" max="1" step="0.01" value="0.5"></div>
      </div>
      <div class="group">
        <h3>Kinematics</h3>
        <div class="row"><label>Cilia length L [μm] <span class="val" id="lengthMeanVal"></span></label><input id="lengthMean" type="range" min="2" max="15" step="0.1" value="10"></div>
        <div class="row"><label>L std [μm] <span class="val" id="lengthStdVal"></span></label><input id="lengthStd" type="range" min="0" max="5" step="0.1" value="1"></div>
        <div class="row"><label>Beat amplitude A [μm] <span class="val" id="ampMeanVal"></span></label><input id="ampMean" type="range" min="0" max="10" step="0.1" value="5"></div>
        <div class="row"><label>A std [μm] <span class="val" id="ampStdVal"></span></label><input id="ampStd" type="range" min="0" max="5" step="0.1" value="0"></div>
        <div class="row"><label>CBF [Hz] <span class="val" id="cbfMeanVal"></span></label><input id="cbfMean" type="range" min="0.5" max="20" step="0.1" value="8"></div>
        <div class="row"><label>CBF std [Hz] <span class="val" id="cbfStdVal"></span></label><input id="cbfStd" type="range" min="0" max="5" step="0.05" value="0.1"></div>
        <div class="row"><label>Wave amp (phase) <span class="val" id="waveAmpVal"></span></label><input id="waveAmp" type="range" min="0" max="1.5" step="0.01" value="0.25"></div>
        <div class="row"><label>Wave angle [deg] <span class="val" id="waveAngleVal"></span></label><input id="waveAngle" type="range" min="-180" max="180" step="1" value="-90"></div>
        <div class="row"><label>Wave noise <span class="val" id="waveNoiseVal"></span></label><input id="waveNoise" type="range" min="0" max="0.5" step="0.01" value="0.02"></div>
        <div class="row"><label>Beat dir std [deg] <span class="val" id="angleStdVal"></span></label><input id="angleStd" type="range" min="0" max="30" step="0.5" value="2"></div>
      </div>
      <div class="group">
        <h3>Camera</h3>
        <div class="row"><label>Azimuth [deg] <span class="val" id="azimuthVal"></span></label><input id="azimuth" type="range" min="-180" max="180" step="1" value="-90"></div>
        <div class="row"><label>Elevation [deg] <span class="val" id="elevationVal"></span></label><input id="elevation" type="range" min="-80" max="80" step="1" value="-5"></div>
        <div class="row"><label>Zoom (radius) <span class="val" id="camRVal"></span></label><input id="camR" type="range" min="10" max="200" step="1" value="50"></div>
      </div>
      <div class="group">
        <h3>Edit</h3>
        <div class="hint">Use header buttons to toggle edit modes. While editing, camera snaps to top view for easier painting. Pause only stops animation — editing stays active.</div>
      </div>
    </aside>

    <main class="canvas-wrap">
      <div id="threeWrap"></div>
      <div id="stats">—</div>
      <div id="err"></div>
    </main>
  </div>

<script type="module">
// ESM helper
async function importWithFallback(candidates){
  for (const url of candidates){ try { return await import(url); } catch(e){ console.warn('Import failed:', url, e); } }
  throw new Error('All import candidates failed');
}
async function loadScript(src){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.async=true; s.src=src; s.onload=()=>res(); s.onerror=()=>rej(new Error('load fail '+src)); document.head.appendChild(s); }); }

// Load THREE (ESM → local ESM → local UMD)
let THREE;
try {
  THREE = await importWithFallback([
    'https://unpkg.com/three@0.160.0/build/three.module.js',
    '/javascripts/vendor/three/0.160.0/three.module.js',
  ]);
} catch (err){
  console.warn('Falling back to UMD THREE:', err);
  await loadScript('/javascripts/vendor/three/0.160.0/three.min.js');
  THREE = window.THREE;
}

// ===== helpers =====
function byId(id){ return document.getElementById(id); }
function setLabel(id, v){ const el = byId(id+'Val'); if (el) el.textContent = String((typeof v==='number')? (Math.round(v*1000)/1000) : v); }
function randn(){ let u=0,v=0; while(!u) u=Math.random(); while(!v) v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
function toSignedDeg(a){ return ((a + 180) % 360 + 360) % 360 - 180; }

// ===== parameters =====
const params = {
  nX:24, nY:20, density:2.0, crystalline:0.8,
  coverage:0.6, patchlength:0.5, patchorder:0.5,
  lengthMean:10, lengthStd:1,
  ampMean:5, ampStd:0,
  cbfMean:8, cbfStd:0.1,
  waveAmp:0.25, waveAngle:-Math.PI/2, waveNoise:0.02,
  angleMean:0, angleStd:2, // deg
  cilRadius:0.20,
  // camera
  azimuth:-90, elevation:-5, camR:50,
  // curvature model
  k0:1.0, aK:0.8,
};

// ===== app state =====
const sim = {
  playing:true,
  scene:null, camera:null, renderer:null,
  cam:{ r:50, az:-90, el:-5 }, q:null, placeCamera:null,
  noSlipPlane:null, planeSize:[10,10],
  // grid + per-cell fields
  total:0,
  cx:null, cy:null, cz:null, isCiliated:null,
  ampScale:null, ciliaLen:null, ciliaFreq:null, initPhase:null,
  beatAngle:null, xSize:0, ySize:0,
  // voronoi + drawing
  vorPolys:null, cellGroup:null,
  // cilia seeds and geometry
  cilia:{ group:null, seeds:null, nSeg:24, mat:null },
  // pointer/edit
  editMode:'none', painting:false, erase:false,
  lastTapTime:0, lastButton:0,
  raycaster: new (THREE.Raycaster||window.THREE.Raycaster)(),
  _savedCam:null,
};

// ===== presence/patch pattern (from existing visualizers) =====
function shape1d(x,a){ const m=((x+1)%2+2)%2; return (m<=2*a)? (m/a-1) : (1-(m-2*a)/(1-a)); }
function presence(cx, cy, coverage, patchlength, crystalline, patchorder, nCols, nRows, dX, dY){
  const n = cx.length; const out = new Array(n);
  function seedAt(x,y){ const px=Math.floor((x + (nCols-1)*dX/2)/dX); const py=Math.floor((y + (nRows-1)*dY/2)/dY); const s=Math.sin(px*12.9898 + py*78.233)*43758.5453; return s - Math.floor(s); }
  for(let i=0;i<n;i++){
    const seed = seedAt(cx[i]+(Math.random()-0.5)*crystalline, cy[i]+(Math.random()-0.5)*crystalline);
    let a = (seed-0.5)*patchorder + 0.5; a=Math.max(0.01, Math.min(0.99, a));
    const pot = Math.min(
      shape1d(cx[i]/Math.max(1,(nCols-1)*dX)/patchlength, a),
      shape1d(cy[i]/Math.max(1,(nRows-1)*dY)/patchlength, a)
    );
    out[i] = (pot >= (1 - 2*coverage));
  }
  return out;
}

// ===== grid and random fields =====
function generateGrid(){
  const nX = Math.max(1, params.nX|0), nY = Math.max(1, params.nY|0);
  const dX = 1/Math.max(0.2, Number(params.density)||1);
  const dY = dX;
  const xSize = (nX-1)*dX, ySize = (nY-1)*dY;
  const coordx = new Array(nX), coordy=new Array(nY);
  for(let i=0;i<nX;i++) coordx[i] = -xSize/2 + (nX>1 ? i*(xSize/(nX-1)) : 0);
  for(let j=0;j<nY;j++) coordy[j] = -ySize/2 + (nY>1 ? j*(ySize/(nY-1)) : 0);
  const cx=[], cy=[], cz=[];
  for(let j=0;j<nY;j++){
    for(let i=0;i<nX;i++){
      const jit = params.crystalline;
      cx.push(coordx[i] + (Math.random()-0.5)*jit);
      cy.push(coordy[j] + (Math.random()-0.5)*jit);
      cz.push(-params.lengthMean/2 + (Math.random()-0.5)*jit);
    }
  }
  sim.cx = new Float32Array(cx); sim.cy = new Float32Array(cy); sim.cz = new Float32Array(cz);
  sim.total = nX*nY; sim.xSize = xSize; sim.ySize = ySize;
  sim.isCiliated = presence(sim.cx, sim.cy, params.coverage, params.patchlength, params.crystalline, params.patchorder||0.5, nX, nY, dX, dY);
  sim.totalCiliated = sim.isCiliated.reduce((a,b)=>a+(b?1:0),0);
  // Only initialize beat angles if not already present or size changed; edits are preserved across kinematic changes
  if (!sim.beatAngle || sim.beatAngle.length !== sim.total){
    sim.beatAngle = new Float32Array(sim.total);
    for (let i=0;i<sim.total;i++){ sim.beatAngle[i] = (params.angleMean + params.angleStd * randn()) * Math.PI/180; }
  }
  reseedRandomFields();
  // Voronoi and seeds depend on centers; compute async and then seed
  updateVoronoi().then(()=>{ initCiliaSeeds(); });
}

function getWave(wAmp, wAng, wNoise, cx, cy, xSize, ySize){
  const n=cx.length; const out=new Float32Array(n);
  const kvx=Math.cos(wAng)*wAmp, kvy=Math.sin(wAng)*wAmp; let base=0;
  for(let i=0;i<n;i++){
    if (xSize===0 && ySize===0) base = 0;
    else if (xSize===0) base = ((kvy * cy[i]/ySize) % 1 + 1) % 1;
    else if (ySize===0) base = ((kvx * cx[i]/xSize) % 1 + 1) % 1;
    else base = ((kvx * cx[i]/xSize + kvy * cy[i]/ySize) % 1 + 1) % 1;
    out[i] = base * (1 - params.waveNoise) + Math.random()*params.waveNoise;
  }
  return out;
}

function reseedRandomFields(){
  const n = sim.total;
  sim.ampScale = new Float32Array(n);
  sim.ciliaLen = new Float32Array(n);
  sim.ciliaFreq = new Float32Array(n);
  for(let i=0;i<n;i++){
    sim.ampScale[i] = Math.max(0, params.ampMean + params.ampStd * randn());
    sim.ciliaLen[i]  = Math.max(0.5, params.lengthMean + params.lengthStd * randn());
    sim.ciliaFreq[i] = Math.max(0, params.cbfMean + params.cbfStd * randn());
  }
  sim.initPhase = getWave(params.waveAmp, params.waveAngle, params.waveNoise, sim.cx, sim.cy, sim.xSize, sim.ySize);
}

// ===== centerline model (from bundle visualizer) =====
function centerlineFromCurvatureN(N, tFrac, A0scale, L, outX, outZ){
  const ds = 1.0/(N-1); const k0=params.k0, aK=params.aK; const twoPiT=2*Math.PI*tFrac;
  let theta_prev=0, x_prev=0, z_prev=0; outX[0]=0; outZ[0]=0;
  function profEval(s){ return 0.2 + 0.8*s; }
  let kappa_prev = k0 + A0scale*aK*aK*profEval(0.0)*Math.cos(aK*2*Math.PI*0.0 - twoPiT);
  for(let i=1;i<N;i++){
    const s=i/(N-1);
    const kappa = k0 + A0scale*aK*aK*profEval(s) * Math.cos(aK*2*Math.PI*s - twoPiT);
    const theta = theta_prev + 0.5*(kappa_prev + kappa)*ds;
    const sx_prev=Math.sin(theta_prev), sz_prev=Math.cos(theta_prev);
    const sx=Math.sin(theta), sz=Math.cos(theta);
    x_prev = x_prev + 0.5*(sx_prev+sx)*ds;
    z_prev = z_prev + 0.5*(sz_prev+sz)*ds;
    outX[i] = x_prev * L; outZ[i] = z_prev * L;
    theta_prev = theta; kappa_prev = kappa;
  }
}

// ===== camera helpers =====
function quatFromAzEl(azDeg, elDeg){
  const az = azDeg*Math.PI/180, el=elDeg*Math.PI/180;
  const cx=Math.cos(el)*Math.cos(az), cy=Math.cos(el)*Math.sin(az), cz=Math.sin(el);
  const f = new THREE.Vector3(-cx,-cy,-cz).normalize();
  const o = new THREE.Object3D(); o.up.set(0,0,1); o.position.set(0,0,0); o.lookAt(new THREE.Vector3().copy(f));
  return o.quaternion.clone();
}
function azElFromQuat(q){ const f=new THREE.Vector3(0,0,-1).applyQuaternion(q).normalize(); const az=toSignedDeg(Math.atan2(-f.y, -f.x)*180/Math.PI); const el=Math.asin(Math.max(-1,Math.min(1,-f.z)))*180/Math.PI; return {az,el}; }

function setupOrbitControls(target){
  if (!target) return;
  let dragging=false, lastX=0, lastY=0;
  const onDown = (e)=>{ if (sim.editMode!=='none') return; dragging=true; lastX=e.clientX; lastY=e.clientY; try{ target.setPointerCapture(e.pointerId);}catch{} e.preventDefault(); };
  const onMove = (e)=>{
    if (!dragging || sim.editMode!=='none') return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
    const s=0.005; // yaw around +Z, then pitch around camera right
    const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -dx*s);
    sim.q.premultiply(qYaw);
    const right = new THREE.Vector3(1,0,0).applyQuaternion(sim.q);
    const qPitch = new THREE.Quaternion().setFromAxisAngle(right, -dy*s);
    sim.q.premultiply(qPitch);
    const ae=azElFromQuat(sim.q); params.azimuth=sim.cam.az=toSignedDeg(ae.az); params.elevation=sim.cam.el=ae.el;
    byId('azimuth').value = String(Math.round(params.azimuth)); byId('elevation').value=String(Math.round(params.elevation)); setLabel('azimuth', params.azimuth); setLabel('elevation', params.elevation);
    sim.placeCamera && sim.placeCamera();
  };
  const onUp = (e)=>{ dragging=false; try{ target.releasePointerCapture(e.pointerId);}catch{} };
  const onWheel = (e)=>{ e.preventDefault(); const dir = e.deltaY>0? 1 : -1; sim.cam.r = Math.max(10, Math.min(200, sim.cam.r + dir*2)); params.camR = sim.cam.r; const rEl=byId('camR'); if (rEl) rEl.value=String(Math.round(sim.cam.r)); setLabel('camR', sim.cam.r); sim.placeCamera && sim.placeCamera(); };
  target.addEventListener('pointerdown', onDown); target.addEventListener('pointermove', onMove); target.addEventListener('pointerup', onUp); target.addEventListener('pointercancel', onUp); target.addEventListener('wheel', onWheel, {passive:false});
}

// ===== scene init =====
function initScene(){
  const wrap = byId('threeWrap');
  sim.scene = new THREE.Scene(); sim.scene.background = new THREE.Color(0x000000);
  const w = wrap.clientWidth || 640, h = wrap.clientHeight || 480;
  sim.camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 2000);
  sim.cam = { r: Number(params.camR)||50, az: params.azimuth, el: params.elevation };
  sim.q = quatFromAzEl(sim.cam.az, sim.cam.el);
  sim.placeCamera = function(){
    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(sim.q);
    const up = new THREE.Vector3(0,1,0).applyQuaternion(sim.q);
    const pos = forward.clone().multiplyScalar(-sim.cam.r);
    sim.camera.position.copy(pos); sim.camera.up.copy(up); sim.camera.lookAt(0,0,0);
  };
  sim.placeCamera();
  sim.renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  sim.renderer.setPixelRatio(Math.min(2, devicePixelRatio||1));
  sim.renderer.setSize(w, h);
  wrap.innerHTML=''; wrap.appendChild(sim.renderer.domElement);
  // lights
  sim.scene.add(new THREE.AmbientLight(0xffffff, 0.8));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(20,20,30); sim.scene.add(dir);
  // plane for picking/visual reference
  updateNoSlipPlane();
  // container groups
  sim.cellGroup = new THREE.Group(); sim.scene.add(sim.cellGroup);
  sim.cilia.group = new THREE.Group(); sim.scene.add(sim.cilia.group);
  sim.cilia.mat = new THREE.LineBasicMaterial({ color:0xffffff, transparent:true, opacity:0.95 });
  // orbit controls (disabled while in edit modes)
  setupOrbitControls(sim.renderer.domElement);
  window.addEventListener('resize', ()=>{ const w2=wrap.clientWidth||640, h2=wrap.clientHeight||480; sim.camera.aspect=w2/h2; sim.camera.updateProjectionMatrix(); sim.renderer.setSize(w2,h2); });
}

function updateNoSlipPlane(){
  const w = Math.max(params.lengthMean, params.nX*(1/Math.max(0.2, params.density)) + params.lengthMean);
  const h = Math.max(params.lengthMean, params.nY*(1/Math.max(0.2, params.density)) + params.lengthMean);
  sim.planeSize = [w,h];
  if (!sim.noSlipPlane){
    const geom = new THREE.PlaneGeometry(w, h);
    const mat = new THREE.MeshStandardMaterial({ color:0x808080, transparent:true, opacity:0.25, roughness:1.0, metalness:0, side:THREE.DoubleSide, depthWrite:false });
    sim.noSlipPlane = new THREE.Mesh(geom, mat); sim.scene.add(sim.noSlipPlane);
  } else {
    const geom = new THREE.PlaneGeometry(w, h); sim.noSlipPlane.geometry.dispose(); sim.noSlipPlane.geometry = geom;
  }
  sim.noSlipPlane.position.set(0,0,0);
}

// ===== Voronoi (cells + boundaries) =====
let DelaunayCtor = null;
async function ensureDelaunay(){
  if (DelaunayCtor) return;
  try {
    const mod = await importWithFallback(['https://cdn.skypack.dev/d3-delaunay@6']);
    DelaunayCtor = mod?.Delaunay ?? mod?.default?.Delaunay ?? mod?.default ?? mod ?? null;
  } catch (err) {
    console.warn('Falling back to local UMD d3-delaunay:', err);
    await loadScript('/javascripts/vendor/d3-delaunay/6/d3-delaunay.min.js');
    DelaunayCtor = (window.d3 && window.d3.Delaunay) ? window.d3.Delaunay : null;
  }
  if (!DelaunayCtor) throw new Error('Delaunay not available');
}
function drawVoronoi(polys){
  // clear old
  if (sim.cellGroup){ while (sim.cellGroup.children.length) sim.cellGroup.remove(sim.cellGroup.children[0]); }
  const edgeMat = new THREE.LineBasicMaterial({ color:0x8892a6, transparent:true, opacity:0.65 });
  for (let i=0;i<polys.length;i++){
    const poly = polys[i]; if (!poly || poly.length<3) continue;
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(poly.length*3);
    for (let k=0;k<poly.length;k++){ pos[3*k+0]=poly[k][0]; pos[3*k+1]=poly[k][1]; pos[3*k+2]=0; }
    g.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const loop = new THREE.LineLoop(g, edgeMat);
    sim.cellGroup.add(loop);
  }
}
async function updateVoronoi(){
  await ensureDelaunay();
  const pts = []; for (let i=0;i<sim.total;i++) pts.push([sim.cx[i], sim.cy[i]]);
  const delaunay = DelaunayCtor.from(pts, d=>d[0], d=>d[1]);
  const bounds = [-sim.xSize/2, -sim.ySize/2, sim.xSize/2, sim.ySize/2];
  const vor = delaunay.voronoi(bounds);
  const polys = new Array(sim.total);
  for (let i=0;i<sim.total;i++){ const poly = vor.cellPolygon(i); polys[i] = poly ? Array.from(poly) : null; }
  sim.vorPolys = polys;
  drawVoronoi(polys);
}

// ===== Cilia seeding per cell (100–150) and geometry =====
function pointInPoly(poly, x, y){ let inside=false; for (let i=0,j=poly.length-1;i<poly.length;j=i++) { const xi=poly[i][0], yi=poly[i][1], xj=poly[j][0], yj=poly[j][1]; const intersect=((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi+1e-12)+xi); if (intersect) inside=!inside; } return inside; }
function initCiliaSeeds(){
  const seeds = new Array(sim.total);
  for (let i=0;i<sim.total;i++){
    if (!sim.isCiliated[i]){ seeds[i]=null; continue; }
    const poly = sim.vorPolys && sim.vorPolys[i]; if (!poly || poly.length<3){ seeds[i]=null; continue; }
    let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity; for (const p of poly){ if (p[0]<minx) minx=p[0]; if (p[0]>maxx) maxx=p[0]; if (p[1]<miny) miny=p[1]; if (p[1]>maxy) maxy=p[1]; }
    const want = 100 + Math.floor(Math.random()*51); // 100..150
    const arr=[]; let tries=0;
    while (arr.length < want && tries < want*80){
      tries++;
      const rx = minx + Math.random()*(maxx-minx);
      const ry = miny + Math.random()*(maxy-miny);
      if (pointInPoly(poly, rx, ry)){
        // per-seed jitters: phase in [0,1), amp ±10%, angle ±5deg
        arr.push({ x:rx, y:ry, dphi: (Math.random()-0.5)*0.1, damp:(Math.random()*0.2-0.1), dang: (Math.random()*10-5)*Math.PI/180 });
      }
    }
    seeds[i]=arr;
  }
  sim.cilia.seeds = seeds;
  buildCiliaGeometry();
}
function buildCiliaGeometry(){
  // clear old
  if (sim.cilia.group){ while (sim.cilia.group.children.length){ const o=sim.cilia.group.children.pop(); if (o.geometry) o.geometry.dispose?.(); } }
  const nSeg = sim.cilia.nSeg;
  const mat = sim.cilia.mat;
  for (let i=0;i<sim.total;i++){
    const seeds = (sim.cilia.seeds && sim.cilia.seeds[i]) || null; if (!seeds) continue;
    for (let k=0;k<seeds.length;k++){
      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(nSeg*3), 3));
      const line = new THREE.Line(geom, mat);
      sim.cilia.group.add(line);
      seeds[k]._line = line; // attach for updates
    }
  }
}
function updateCilia(time){
  const nSeg = sim.cilia.nSeg; const xLine = new Float32Array(nSeg), zLine = new Float32Array(nSeg);
  for (let cell=0; cell<sim.total; cell++){
    if (!sim.isCiliated[cell]) continue;
    const seeds = sim.cilia.seeds && sim.cilia.seeds[cell]; if (!seeds) continue;
    const t0 = (time * sim.ciliaFreq[cell] + sim.initPhase[cell]) % 1.0;
    const L = sim.ciliaLen[cell]; const baseA = sim.ampScale[cell];
    for (let sIdx=0; sIdx<seeds.length; sIdx++){
      const sd = seeds[sIdx]; const line = sd._line; if (!line) continue;
      const tFrac = (t0 + (sd.dphi||0) + 10) % 1.0;
      const A0 = baseA * (1 + (sd.damp||0));
      centerlineFromCurvatureN(nSeg, tFrac, A0, L, xLine, zLine);
      const a = sim.beatAngle[cell] + (sd.dang||0); const ss=Math.sin(a), cc=Math.cos(a);
      const pos = line.geometry.attributes.position.array;
      for (let i=0;i<nSeg;i++){
        const j3=i*3; const xp=xLine[i], zp=zLine[i];
        const xc = xp*cc + sd.x;
        const yc = -xp*ss + sd.y;
        const zc = zp + 0; // plane z=0
        pos[j3+0]=xc; pos[j3+1]=yc; pos[j3+2]=zc;
      }
      line.geometry.attributes.position.needsUpdate = true;
      line.visible = true;
    }
  }
}

// ===== editing =====
function worldOnPlaneFromEvent(e){
  if (!sim.renderer || !sim.camera || !sim.noSlipPlane) return null;
  const rect = sim.renderer.domElement.getBoundingClientRect();
  const x = ((e.clientX - rect.left) / Math.max(1, rect.width))*2 - 1;
  const y = -(((e.clientY - rect.top) / Math.max(1, rect.height))*2 - 1);
  sim.raycaster.setFromCamera({x,y}, sim.camera);
  const hit = sim.raycaster.intersectObject(sim.noSlipPlane, false);
  if (hit && hit.length){ const p=hit[0].point; return [p.x, p.y, p.z]; }
  return null;
}
function nearestCellIndexNoPBC(x,y){
  let best=-1, bestD=Infinity; const n=sim.total;
  for (let i=0;i<n;i++){ const dx=x-sim.cx[i], dy=y-sim.cy[i]; const d2=dx*dx+dy*dy; if (d2<bestD){ bestD=d2; best=i; } }
  return best;
}
function paintFateSegment(x0,y0,x1,y1, makeCiliated){
  const dx=x1-x0, dy=y1-y0; const dist=Math.hypot(dx,dy); const step = Math.max(0.25, Math.min(0.6, 0.5)); const n = Math.max(1, Math.ceil(dist/step));
  for (let k=0;k<=n;k++){
    const x=x0 + dx*(k/n), y=y0 + dy*(k/n); const idx=nearestCellIndexNoPBC(x,y);
    if (idx>=0){
      const before = !!sim.isCiliated[idx];
      const after = !!makeCiliated;
      if (before !== after){
        sim.isCiliated[idx] = after;
        regenSeedsForIndex(idx);
      }
    }
  }
}
function paintDirSegment(x0,y0,x1,y1){
  const dx=x1-x0, dy=y1-y0; const dist=Math.hypot(dx,dy) || 0; if (dist<=1e-9) return;
  const ang=Math.atan2(dy,dx);
  const step=Math.max(0.25, Math.min(0.6, 0.5)); const n=Math.max(1, Math.ceil(dist/step));
  for (let k=0;k<=n;k++){
    const x=x0+dx*(k/n), y=y0+dy*(k/n); const idx=nearestCellIndexNoPBC(x,y);
    if (idx>=0 && sim.isCiliated[idx]) sim.beatAngle[idx] = ang;
  }
}
function bindEditing(){
  const c = sim.renderer?.domElement; if (!c) return;
  let lastWX=0, lastWY=0; let isRight=false;
  c.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });
  c.addEventListener('pointerdown', (e)=>{
    // erase with right click or shift
    isRight = (e.button===2) || e.shiftKey;
    if (sim.editMode==='none') return; // orbitControls handles
    const p = worldOnPlaneFromEvent(e); if (!p) return; sim.painting=true; lastWX=p[0]; lastWY=p[1];
    if (sim.editMode==='fate'){
      paintFateSegment(lastWX,lastWY,lastWX,lastWY, !isRight);
    }
    e.preventDefault();
  }, {passive:false});
  c.addEventListener('pointermove', (e)=>{
    if (!sim.painting || sim.editMode==='none') return;
    const p = worldOnPlaneFromEvent(e); if (!p) return; const wx=p[0], wy=p[1];
    if (sim.editMode==='fate') paintFateSegment(lastWX,lastWY,wx,wy, !isRight);
    else if (sim.editMode==='dir') paintDirSegment(lastWX,lastWY,wx,wy);
    lastWX=wx; lastWY=wy; e.preventDefault();
  }, {passive:false});
  c.addEventListener('pointerup', ()=>{ sim.painting=false; });
  c.addEventListener('pointercancel', ()=>{ sim.painting=false; });
}

function regenSeedsForIndex(i){
  if (!sim.vorPolys || !sim.cilia || !sim.cilia.group) return;
  // remove old geometry for this cell
  const old = sim.cilia.seeds && sim.cilia.seeds[i];
  if (old && old.length){ for (const sd of old){ if (sd && sd._line){ try{ sim.cilia.group.remove(sd._line); sd._line.geometry?.dispose?.(); }catch{} } } }
  if (!sim.cilia.seeds) sim.cilia.seeds = new Array(sim.total);
  if (!sim.isCiliated[i]){ sim.cilia.seeds[i]=null; return; }
  const poly = sim.vorPolys[i]; if (!poly || poly.length<3){ sim.cilia.seeds[i]=null; return; }
  let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity; for (const p of poly){ if (p[0]<minx) minx=p[0]; if (p[0]>maxx) maxx=p[0]; if (p[1]<miny) miny=p[1]; if (p[1]>maxy) maxy=p[1]; }
  const want = 100 + Math.floor(Math.random()*51);
  const arr=[]; let tries=0;
  while (arr.length < want && tries < want*80){
    tries++;
    const rx = minx + Math.random()*(maxx-minx);
    const ry = miny + Math.random()*(maxy-miny);
    if (pointInPoly(poly, rx, ry)){
      arr.push({ x:rx, y:ry, dphi:(Math.random()-0.5)*0.1, damp:(Math.random()*0.2-0.1), dang:(Math.random()*10-5)*Math.PI/180 });
    }
  }
  // build geometry for new seeds
  const nSeg = sim.cilia.nSeg; const mat = sim.cilia.mat;
  for (let k=0;k<arr.length;k++){
    const geom = new THREE.BufferGeometry(); geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(nSeg*3),3));
    const line = new THREE.Line(geom, mat); sim.cilia.group.add(line); arr[k]._line = line;
  }
  sim.cilia.seeds[i] = arr;
}

// ===== UI wiring =====
function connectUI(){
  const appEl = document.querySelector('.app');
  const toggleBtn = byId('togglePanel');
  const collapseQuery = window.matchMedia('(max-width: 900px)');
  let userLockedPanel=false;
  const setCollapsed=(collapsed)=>{ appEl.classList.toggle('collapsed', !!collapsed); toggleBtn.setAttribute('aria-expanded', String(!collapsed)); toggleBtn.textContent = collapsed ? '»' : '«'; };
  setCollapsed(collapseQuery.matches);
  const onChange=(e)=>{ if (!userLockedPanel) setCollapsed(e.matches); };
  collapseQuery.addEventListener?.('change', onChange); collapseQuery.addListener?.(onChange);
  toggleBtn.addEventListener('click', ()=>{ userLockedPanel=true; setCollapsed(!appEl.classList.contains('collapsed')); });

  function bindRange(id, key, toVal){ const el=byId(id); if (!el) return; const apply=()=>{ let v=Number(el.value); if (id==='waveAngle') v = v*Math.PI/180; if (key==='angleStd') { setLabel(id, Number(el.value)); params[key] = Number(el.value); } else { params[key]=v; setLabel(id, v); } onParamChange(key); }; el.addEventListener('input', apply); setLabel(id, Number(el.value)); }
  bindRange('nX','nX'); bindRange('nY','nY'); bindRange('density','density'); bindRange('crystalline','crystalline'); bindRange('coverage','coverage'); bindRange('patchlength','patchlength'); bindRange('patchorder','patchorder');
  bindRange('lengthMean','lengthMean'); bindRange('lengthStd','lengthStd'); bindRange('ampMean','ampMean'); bindRange('ampStd','ampStd'); bindRange('cbfMean','cbfMean'); bindRange('cbfStd','cbfStd'); bindRange('waveAmp','waveAmp'); bindRange('waveAngle','waveAngle'); bindRange('waveNoise','waveNoise'); bindRange('angleStd','angleStd');
  bindRange('azimuth','azimuth'); bindRange('elevation','elevation'); bindRange('camR','camR');
  const btnFate = byId('modeFate');
  const btnDir  = byId('modeBeatDir');
  function setMode(m){
    const prev = sim.editMode;
    sim.editMode = m;
    const isF=(m==='fate'), isD=(m==='dir');
    if (btnFate){ btnFate.classList.toggle('active', isF); btnFate.setAttribute('aria-pressed', String(isF)); btnFate.textContent = isF? 'edit: cell fate (on)' : 'edit: cell fate'; }
    if (btnDir){ btnDir.classList.toggle('active', isD); btnDir.setAttribute('aria-pressed', String(isD)); btnDir.textContent = isD? 'edit: beat direction (on)' : 'edit: beat direction'; }
    // camera snap while entering edit; restore when leaving
    if (prev==='none' && (isF||isD)){
      sim._savedCam = { q: sim.q.clone(), r: sim.cam.r, az: sim.cam.az, el: sim.cam.el };
      // top view (near-orthographic): elevation ~80°
      sim.cam.el = 80; sim.cam.az = 0; sim.q = quatFromAzEl(sim.cam.az, sim.cam.el); sim.placeCamera && sim.placeCamera();
    } else if ((prev==='fate' || prev==='dir') && m==='none' && sim._savedCam){
      sim.q.copy(sim._savedCam.q); sim.cam.r = sim._savedCam.r; sim.cam.az = sim._savedCam.az; sim.cam.el = sim._savedCam.el; sim._savedCam=null; sim.placeCamera && sim.placeCamera();
    }
  }
  btnFate?.addEventListener('click', ()=>{ setMode(sim.editMode==='fate' ? 'none' : 'fate'); });
  btnDir?.addEventListener('click',  ()=>{ setMode(sim.editMode==='dir'  ? 'none' : 'dir');  });
  byId('playPause')?.addEventListener('click', ()=>{ sim.playing = !sim.playing; byId('playPause').textContent = sim.playing ? 'Pause' : 'Play'; /* editing unaffected */ });
}

function onParamChange(key){
  const gridKeys = new Set(['nX','nY','density','crystalline','coverage','patchlength','patchorder']);
  if (key==='azimuth' || key==='elevation' || key==='camR'){
    if (key==='azimuth') sim.cam.az = params.azimuth; if (key==='elevation') sim.cam.el = params.elevation; if (key==='camR') sim.cam.r = params.camR;
    sim.q = quatFromAzEl(sim.cam.az, sim.cam.el); sim.placeCamera && sim.placeCamera(); return;
  }
  if (key==='waveAngle') { params.waveAngle = Number(byId('waveAngle').value) * Math.PI/180; }
  if (gridKeys.has(key)){
    generateGrid(); updateNoSlipPlane(); return;
  }
  if (['lengthMean','lengthStd','ampMean','ampStd','cbfMean','cbfStd','angleStd'].includes(key)){
    reseedRandomFields(); return;
  }
  if (['waveAmp','waveNoise'].includes(key)) { sim.initPhase = getWave(params.waveAmp, params.waveAngle, params.waveNoise, sim.cx, sim.cy, sim.xSize, sim.ySize); return; }
}

// ===== main loop =====
let tNow=0, lastT=performance.now(), acc=0;
function loop(now){
  requestAnimationFrame(loop);
  const dt=(now-lastT)/1000; lastT=now; acc+=dt;
  if (sim.playing){ if (acc>=0.016){ acc=0; tNow += 0.02; updateCilia(tNow); } }
  if (sim.renderer) sim.renderer.render(sim.scene, sim.camera);
  const statsEl = byId('stats'); if (statsEl){ statsEl.textContent = `cells: ${sim.total}  ciliated: ${sim.isCiliated? sim.isCiliated.filter(Boolean).length : 0}`; }
}

// ===== boot =====
function boot(){
  // init camera values
  sim.cam.r = Number(params.camR)||50; sim.cam.az=params.azimuth; sim.cam.el=params.elevation;
  initScene();
  generateGrid();
  connectUI();
  bindEditing();
  requestAnimationFrame(loop);
}
boot();

// minimal self-check
console.assert(byId('threeWrap'), 'Missing threeWrap');
</script>
</body>
</html>
